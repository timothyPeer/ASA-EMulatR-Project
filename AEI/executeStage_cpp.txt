#include "executeStage.h"





/*

Complete Alpha instruction execution: All TODO:: major instruction types properly implemented

Pipeline management: Instruction queuing, stalling, and flushing

Exception handling: Proper exception detection and triggering

Performance monitoring: Detailed statistics on instruction types and execution rates

Debug logging: Comprehensive logging for all operations

Qt integration: Signals for monitoring execution progress

Floating-point support: Full IEEE and VAX floating-point operation handling

PAL support: Privileged operation execution

*/

// ExecuteStage.cpp

#include "AlphaCPU.h"

#include "TraceManager.h"

#include "decodeStage.h"

#include "GlobalMacro.h"

#include "fetchUnit.h"

#include "PlatformPalOpCodes.h"

#include "decodedInstruction.h"



ExecuteStage::ExecuteStage(QObject* parent) : QObject(parent), m_busy(false) { DEBUG_LOG("ExecuteStage initialized"); }



void ExecuteStage::execute(const DecodedInstruction &instruction)

{

    if (!instruction.valid)

    {

        DEBUG_LOG("ExecuteStage: Attempted to execute invalid instruction");

        emit executionError("Invalid instruction");

        return;

    }



    m_busy = true;



    DEBUG_LOG(QString("ExecuteStage: Executing instruction 0x%1 (opcode=0x%2)")

                  .arg(instruction.rawInstruction, 8, 16, QChar('0'))

                  .arg(instruction.opcode, 2, 16, QChar('0')));



    // Check if pipeline is stalled

    if (m_stallCycles > 0)

    {

        m_stallCycles--;

        m_busy = false;

        return;

    }



    // Add instruction to pipeline

    if (m_pipelineStages.size() >= m_pipelineDepth)

    {

        // Pipeline is full, we need to wait

        DEBUG_LOG("ExecuteStage: Pipeline full, queueing instruction");

        m_instructionQueue.enqueue(instruction);

        m_busy = false;

        return;

    }



    m_pipelineStages.enqueue(instruction);

    try

    {

        switch (instruction.opcode)

        {

        // Memory instructions

        case OPCODE_LDA:  // LDA - Load Address

        case OPCODE_LDAH: // LDAH - Load Address High

        {

            executeLoadAddress(instruction);

            break;

        }



        case OPCODE_LDBU:  // LDBU - Load Byte Unsigned

        case OPCODE_LDQ_U: // LDQ_U - Load Quadword Unaligned

        case OPCODE_LDWU:  // LDWU - Load Word Unsigned

        {

            executeLoadUnaligned(instruction);

            break;

        }



        case OPCODE_STW:   // STW - Store Word

        case OPCODE_STB:   // STB - Store Byte

        case OPCODE_STQ_U: // STQ_U - Store Quadword Unaligned

        {

            executeStoreUnaligned(instruction);

            break;

        }



        case OPCODE_LDF: // LDF - Load F_floating

        case OPCODE_LDG: // LDG - Load G_floating

        case OPCODE_LDS: // LDS - Load S_floating

        case OPCODE_LDT: // LDT - Load T_floating

        {

            executeFloatingPointLoad(instruction);

            break;

        }



        case OPCODE_STF: // STF - Store F_floating

        case OPCODE_STG: // STG - Store G_floating

        case OPCODE_STS: // STS - Store S_floating

        case OPCODE_STT: // STT - Store T_floating

        {

            executeFloatingPointStore(instruction);

            break;

        }



        case OPCODE_LDL:   // LDL - Load Longword

        case OPCODE_LDQ:   // LDQ - Load Quadword

        case OPCODE_LDL_L: // LDL_L - Load Longword Locked

        case OPCODE_LDQ_L: // LDQ_L - Load Quadword Locked

        {

            executeLoad(instruction);

            break;

        }



        case OPCODE_STL:   // STL - Store Longword

        case OPCODE_STQ:   // STQ - Store Quadword

        case OPCODE_STL_C: // STL_C - Store Longword Conditional

        case OPCODE_STQ_C: // STQ_C - Store Quadword Conditional

        {

            executeStore(instruction);

            break;

        }



        // Branch instructions

        case OPCODE_BR:  // BR - Branch

        case OPCODE_BSR: // BSR - Branch to Subroutine

        {

            executeBranch(instruction);

            break;

        }



        case OPCODE_BEQ: // BEQ - Branch if Equal

        case OPCODE_BNE: // BNE - Branch if Not Equal

        case OPCODE_BLT: // BLT - Branch if Less Than

        case OPCODE_BGE: // BGE - Branch if Greater Than or Equal

        case OPCODE_BLE: // BLE - Branch if Less Than or Equal

        case OPCODE_BGT: // BGT - Branch if Greater Than

        {

            executeConditionalBranch(instruction);

            break;

        }



        case OPCODE_BLBC: // BLBC - Branch if Low Bit Clear

        case OPCODE_BLBS: // BLBS - Branch if Low Bit Set

        {

            executeBitTestBranch(instruction);

            break;

        }



        case OPCODE_FBEQ: // FBEQ - Floating Branch if Equal

        case OPCODE_FBLT: // FBLT - Floating Branch if Less Than

        case OPCODE_FBLE: // FBLE - Floating Branch if Less Than or Equal

        case OPCODE_FBNE: // FBNE - Floating Branch if Not Equal

        case OPCODE_FBGE: // FBGE - Floating Branch if Greater Than or Equal

        case OPCODE_FBGT: // FBGT - Floating Branch if Greater Than

        {

            executeFloatingPointBranch(instruction);

            break;

        }



        // Operate instructions

        case OPCODE_INTA: // INTA - Integer arithmetic

        {

            executeIntegerArithmetic(instruction);

            break;

        }

        case OPCODE_INTL: // INTL - Integer logical

        {

            executeIntegerLogical(instruction);

            break;

        }



        case OPCODE_INTS: // INTS - Integer shift

        {

            executeIntegerShift(instruction);

            break;

        }



        case OPCODE_INTM: // INTM - Integer multiply

        {

            executeIntegerMultiply(instruction);

            break;

        }



        case OPCODE_ITFP: // ITFP - Integer to floating-point

        {

            executeIntegerToFloat(instruction);

            break;

        }



        case OPCODE_FLTV: // FLTV - Floating-point VAX

        case OPCODE_FLTI: // FLTI - Floating-point IEEE

        case OPCODE_FLTL: // FLTL - Floating-point convert

        {

            executeFloatingPointOperate(instruction);

            break;

        }



        // PAL instructions

        case OPCODE_PAL:

        {

            executePAL(instruction);

            break;

        }



        // Jump instructions

        case OPCODE_JSR:

        {

            executeJump(instruction);

            break;

        }



        default:

        {

            DEBUG_LOG(QString("ExecuteStage: Unknown opcode 0x%1").arg(instruction.opcode, 2, 16, QChar('0')));

            m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

            break;

        }

        }



        // Update statistics

        updateStatistics(instruction);



        // Emit signal

        emit sigInstructionExecuted(instruction);

    }

    catch (const std::exception &e)

    {

        DEBUG_LOG(QString("ExecuteStage: Exception during execution - %1").arg(e.what()));

        emit executionError(QString("Execution exception: %1").arg(e.what()));

        m_cpu->triggerException(AlphaCPU::GENERAL_EXCEPTION, m_cpu->getPC());

    }

    m_executionCycles++;

    //m_busy = false;



    // Check if there are queued instructions to process

    if (!m_instructionQueue.isEmpty() && m_pipelineStages.size() < m_pipelineDepth)

    {

        DecodedInstruction nextInstruction = m_instructionQueue.dequeue();

        execute(nextInstruction);

    }

}



void ExecuteStage::stall(quint32 cycles)

{

    m_stallCycles = cycles;

    m_stallCyclesTotal += cycles;

    emit pipelineStalled(cycles);



    DEBUG_LOG(QString("ExecuteStage: Pipeline stalled for %1 cycles").arg(cycles));

}



bool ExecuteStage::isStalled() const { return m_stallCycles > 0; }



void ExecuteStage::updateStatistics(const DecodedInstruction &instruction)

{

    QMutexLocker locker(&m_statsMutex);



    m_totalInstructions++;



    // Categorize instruction type

    switch (instruction.opcode)

    {

    // Integer arithmetic and logical

    case OPCODE_INTA:

    case OPCODE_INTL:

    case OPCODE_INTS:

    case OPCODE_INTM:

        m_integerInstructions++;

        break;



    // Floating-point operations

    case OPCODE_ITFP:

    case OPCODE_FLTV:

    case OPCODE_FLTI:

    case OPCODE_FLTL:

    case OPCODE_LDF:

    case OPCODE_LDG:

    case OPCODE_LDS:

    case OPCODE_LDT:

    case OPCODE_STF:

    case OPCODE_STG:

    case OPCODE_STS:

    case OPCODE_STT:

        m_floatingPointInstructions++;

        break;



    // Memory operations

    case OPCODE_LDA:

    case OPCODE_LDAH:

    case OPCODE_LDBU:

    case OPCODE_LDQ_U:

    case OPCODE_LDWU:

    case OPCODE_STW:

    case OPCODE_STB:

    case OPCODE_STQ_U:

    case OPCODE_LDL:

    case OPCODE_LDQ:

    case OPCODE_LDL_L:

    case OPCODE_LDQ_L:

    case OPCODE_STL:

    case OPCODE_STQ:

    case OPCODE_STL_C:

    case OPCODE_STQ_C:

        m_memoryInstructions++;

        break;



    // Branch operations

    case OPCODE_BR:

    case OPCODE_FBEQ:

    case OPCODE_FBLT:

    case OPCODE_FBLE:

    case OPCODE_BSR:

    case OPCODE_FBNE:

    case OPCODE_FBGE:

    case OPCODE_FBGT:

    case OPCODE_BLBC:

    case OPCODE_BEQ:

    case OPCODE_BLT:

    case OPCODE_BLE:

    case OPCODE_BLBS:

    case OPCODE_BNE:

    case OPCODE_BGE:

    case OPCODE_BGT:

    case OPCODE_JSR: // Jump instructions

        m_branchInstructions++;

        break;



    // PAL operations

    case OPCODE_PAL:

        m_palInstructions++;

        break;

    }

}



void ExecuteStage::updateBranchStatistics(bool mispredicted)

{

    QMutexLocker locker(&m_statsMutex);



    if (mispredicted)

    {

        m_branchMispredictions++;

    }

}



QString ExecuteStage::getInstructionTypeName(quint8 opcode) const

{

    switch (opcode)

    {

    case OPCODE_LDA:

        return "LDA"; // Confirmed

    case OPCODE_LDAH:

        return "LDAH"; // Confirmed

    case OPCODE_LDBU:

        return "LDBU"; // Confirmed

    case OPCODE_LDQ_U:

        return "LDQ_U"; // Confirmed

    case OPCODE_LDWU:

        return "LDWU"; // Confirmed

    case OPCODE_STW:

        return "STW";

    case OPCODE_STB:

        return "STB";

    case OPCODE_STQ_U:

        return "STQ_U";

    case OPCODE_INTA:

        return "INTA";

    case OPCODE_INTL:

        return "INTL";

    case OPCODE_INTS:

        return "INTS";

    case OPCODE_INTM:

        return "INTM";

    case OPCODE_ITFP:

        return "ITFP";

    case OPCODE_FLTV:

        return "FLTV";

    case OPCODE_FLTI:

        return "FLTI";

    case OPCODE_FLTL:

        return "FLTL";

    case OPCODE_JSR:

        return "JUMP";

    case OPCODE_LDF:

        return "LDF";

    case OPCODE_LDG:

        return "LDG";

    case OPCODE_LDS:

        return "LDS";

    case OPCODE_LDT:

        return "LDT";

    case OPCODE_STF:

        return "STF";

    case OPCODE_STG:

        return "STG";

    case OPCODE_STS:

        return "STS";

    case OPCODE_STT:

        return "STT";

    case OPCODE_LDL:

        return "LDL";

    case OPCODE_LDQ:

        return "LDQ";

    case OPCODE_LDL_L:

        return "LDL_L";

    case OPCODE_LDQ_L:

        return "LDQ_L";

    case OPCODE_STL:

        return "STL";

    case OPCODE_STQ:

        return "STQ";

    case OPCODE_STL_C:

        return "STL_C";

    case OPCODE_STQ_C:

        return "STQ_C";

    case OPCODE_BR:

        return "BR";

    case OPCODE_FBEQ:

        return "FBEQ";

    case OPCODE_FBLT:

        return "FBLT";

    case OPCODE_FBLE:

        return "FBLE";

    case OPCODE_BSR:

        return "BSR";

    case OPCODE_FBNE:

        return "FBNE";

    case OPCODE_FBGE:

        return "FBGE";

    case OPCODE_FBGT:

        return "FBGT";

    case OPCODE_BLBC:

        return "BLBC";

    case OPCODE_BEQ:

        return "BEQ";

    case OPCODE_BLT:

        return "BLT";

    case OPCODE_BLE:

        return "BLE";

    case OPCODE_BLBS:

        return "BLBS";

    case OPCODE_BNE:

        return "BNE";

    case OPCODE_BGE:

        return "BGE";

    case OPCODE_BGT:

        return "BGT";

    case OPCODE_PAL:

        return "PAL";

    default:

        return QString("UNK_0x%1").arg(opcode, 2, 16, QChar('0'));

    }

}



void ExecuteStage::printStatistics() const

{

    QMutexLocker locker(&m_statsMutex);



    if (m_totalInstructions == 0)

    {

        DEBUG_LOG("ExecuteStage: No instructions executed yet");

        return;

    }



    double integerRate = (double)m_integerInstructions / m_totalInstructions * 100.0;

    double fpRate = (double)m_floatingPointInstructions / m_totalInstructions * 100.0;

    double memoryRate = (double)m_memoryInstructions / m_totalInstructions * 100.0;

    double branchRate = (double)m_branchInstructions / m_totalInstructions * 100.0;

    double palRate = (double)m_palInstructions / m_totalInstructions * 100.0;



    double mispredictionRate =

        m_branchInstructions > 0 ? (double)m_branchMispredictions / m_branchInstructions * 100.0 : 0.0;



    double executionRate = m_executionCycles > 0 ? (double)m_totalInstructions / m_executionCycles : 0.0;



    double stallRate = m_executionCycles > 0 ? (double)m_stallCyclesTotal / m_executionCycles * 100.0 : 0.0;



    DEBUG_LOG("ExecuteStage Statistics:");

    DEBUG_LOG(QString("  Total Instructions: %1").arg(m_totalInstructions));

    DEBUG_LOG(QString("  Execution Cycles: %1").arg(m_executionCycles));

    DEBUG_LOG(QString("  Instructions per Cycle: %1").arg(executionRate, 0, 'f', 3));

    DEBUG_LOG(QString("  Integer Instructions: %1 (%2%)").arg(m_integerInstructions).arg(integerRate, 0, 'f', 2));

    DEBUG_LOG(

        QString("  Floating-Point Instructions: %1 (%2%)").arg(m_floatingPointInstructions).arg(fpRate, 0, 'f', 2));

    DEBUG_LOG(QString("  Memory Instructions: %1 (%2%)").arg(m_memoryInstructions).arg(memoryRate, 0, 'f', 2));

    DEBUG_LOG(QString("  Branch Instructions: %1 (%2%)").arg(m_branchInstructions).arg(branchRate, 0, 'f', 2));

    DEBUG_LOG(QString("  PAL Instructions: %1 (%2%)").arg(m_palInstructions).arg(palRate, 0, 'f', 2));

    DEBUG_LOG(

        QString("  Branch Mispredictions: %1 (%2%)").arg(m_branchMispredictions).arg(mispredictionRate, 0, 'f', 2));

    DEBUG_LOG(QString("  Pipeline Stalls: %1 cycles (%2%)").arg(m_stallCyclesTotal).arg(stallRate, 0, 'f', 2));

}



void ExecuteStage::clearStatistics()

{

    QMutexLocker locker(&m_statsMutex);



    m_totalInstructions = 0;

    m_integerInstructions = 0;

    m_floatingPointInstructions = 0;

    m_memoryInstructions = 0;

    m_branchInstructions = 0;

    m_branchMispredictions = 0;

    m_palInstructions = 0;

    m_executionCycles = 0;

    m_stallCyclesTotal = 0;



    DEBUG_LOG("ExecuteStage: Statistics cleared");

}



double ExecuteStage::getInstructionExecutionRate() const

{

    QMutexLocker locker(&m_statsMutex);

    return m_executionCycles > 0 ? (double)m_totalInstructions / m_executionCycles : 0.0;

}



quint64 ExecuteStage::getExecutedInstructions() const

{

    QMutexLocker locker(&m_statsMutex);

    return m_totalInstructions;

}



quint64 ExecuteStage::getBranchMispredictions() const

{

    QMutexLocker locker(&m_statsMutex);

    return m_branchMispredictions;

}



void ExecuteStage::flush()

{

    // Clear instruction queue and pipeline stages

    m_instructionQueue.clear();

    m_pipelineStages.clear();

    m_busy = false;

    m_stallCycles = 0;



    DEBUG_LOG("ExecuteStage: Pipeline flushed");

}



// Implementation of specific instruction types

void ExecuteStage::executeLoadAddress(const DecodedInstruction &instruction)

{

    // LDA/LDAH - Calculate effective address

    quint64 baseValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);

    quint64 result;



    if (instruction.opcode == OPCODE_LDA) // LDA

    {

        result = baseValue + instruction.immediate;

    }

    else // LDAH

    {

        result = baseValue + (instruction.immediate << 16);

    }



    // Store result in destination register

    if (instruction.ra != 31) // Don't write to R31 (hardwired zero)

    {

        m_cpu->setRegister(instruction.ra, result);

    }



    DEBUG_LOG(QString("ExecuteStage: %1 R%2,#%3(R%4) -> R%2=0x%5")

                  .arg(instruction.opcode == OPCODE_LDA ? "LDA" : "LDAH")

                  .arg(instruction.ra)

                  .arg(instruction.immediate)

                  .arg(instruction.rb)

                  .arg(result, 16, 16, QChar('0')));

}



void ExecuteStage::executeLoad(const DecodedInstruction &instruction)

{

    // Calculate effective address

    quint64 baseValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);

    quint64 effectiveAddress = baseValue + instruction.immediate;



    DEBUG_LOG(QString("ExecuteStage: Load from EA=0x%1 (base=0x%2 + disp=%3)")

                  .arg(effectiveAddress, 16, 16, QChar('0'))

                  .arg(baseValue, 16, 16, QChar('0'))

                  .arg(instruction.immediate));



    switch (instruction.opcode)

    {

    case OPCODE_LDL: // LDL - Load Longword

    {

        qint32 value;

        if (m_cpu->readMemory32(effectiveAddress, reinterpret_cast<quint32 &>(value)))

        {

            // Sign-extend to 64 bits

            quint64 result = static_cast<quint64>(static_cast<qint64>(value));

            if (instruction.ra != 31)

            {

                m_cpu->setRegister(instruction.ra, result);

            }

            DEBUG_LOG(QString("ExecuteStage: LDL R%1 = 0x%2").arg(instruction.ra).arg(result, 16, 16, QChar('0')));

        }

        else

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        break;

    }



    case OPCODE_LDQ: // LDQ - Load Quadword

    {

        quint64 value;

        if (m_cpu->readMemory64(effectiveAddress, value))

        {

            if (instruction.ra != 31)

            {

                m_cpu->setRegister(instruction.ra, value);

            }

            DEBUG_LOG(QString("ExecuteStage: LDQ R%1 = 0x%2").arg(instruction.ra).arg(value, 16, 16, QChar('0')));

        }

        else

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        break;

    }



    case OPCODE_LDL_L: // LDL_L - Load Longword Locked

    {

        qint32 value;

        if (m_cpu->readMemory32Locked(effectiveAddress, reinterpret_cast<quint32 &>(value)))

        {

            quint64 result = static_cast<quint64>(static_cast<qint64>(value));

            if (instruction.ra != 31)

            {

                m_cpu->setRegister(instruction.ra, result);

            }

            DEBUG_LOG(QString("ExecuteStage: LDL_L R%1 = 0x%2").arg(instruction.ra).arg(result, 16, 16, QChar('0')));

        }

        else

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        break;

    }



    case OPCODE_LDQ_L: // LDQ_L - Load Quadword Locked

    {

        quint64 value;

        if (m_cpu->readMemory64Locked(effectiveAddress, value))

        {

            if (instruction.ra != 31)

            {

                m_cpu->setRegister(instruction.ra, value);

            }

            DEBUG_LOG(QString("ExecuteStage: LDQ_L R%1 = 0x%2").arg(instruction.ra).arg(value, 16, 16, QChar('0')));

        }

        else

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        break;

    }

    }

}



void ExecuteStage::executeStore(const DecodedInstruction &instruction)

{

    // Calculate effective address

    quint64 baseValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);

    quint64 effectiveAddress = baseValue + instruction.immediate;

    quint64 storeValue = (instruction.ra == 31) ? 0 : m_cpu->getRegister(instruction.ra);



    DEBUG_LOG(QString("ExecuteStage: Store to EA=0x%1, value=0x%2")

                  .arg(effectiveAddress, 16, 16, QChar('0'))

                  .arg(storeValue, 16, 16, QChar('0')));



    switch (instruction.opcode)

    {

    case OPCODE_STL: // STL - Store Longword

    {

        quint32 value = static_cast<quint32>(storeValue);

        if (!m_cpu->writeMemory32(effectiveAddress, value))

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        DEBUG_LOG("ExecuteStage: STL completed");

        break;

    }



    case OPCODE_STQ: // STQ - Store Quadword

    {

        if (!m_cpu->writeMemory64(effectiveAddress, storeValue))

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        DEBUG_LOG("ExecuteStage: STQ completed");

        break;

    }



    case OPCODE_STL_C: // STL_C - Store Longword Conditional

    {

        quint32 value = static_cast<quint32>(storeValue);

        bool success = m_cpu->writeMemory32Conditional(effectiveAddress, value);



        // Store success/failure in Ra (0 = failed, 1 = succeeded)

        if (instruction.ra != 31)

        {

            m_cpu->setRegister(instruction.ra, success ? 1 : 0);

        }

        DEBUG_LOG(QString("ExecuteStage: STL_C %1").arg(success ? "succeeded" : "failed"));

        break;

    }



    case OPCODE_STQ_C: // STQ_C - Store Quadword Conditional

    {

        bool success = m_cpu->writeMemory64Conditional(effectiveAddress, storeValue);



        // Store success/failure in Ra (0 = failed, 1 = succeeded)

        if (instruction.ra != 31)

        {

            m_cpu->setRegister(instruction.ra, success ? 1 : 0);

        }

        DEBUG_LOG(QString("ExecuteStage: STQ_C %1").arg(success ? "succeeded" : "failed"));

        break;

    }

    }

}



/*

Function    Name    Operation

0x1D        CMPULT  Unsigned less than (treats lower 32 bits as unsigned)

0x1F        CMPULE  Unsigned less than or equal (treats lower 32 bits as unsigned)

0x2D        CMPEQ   Equal

0x2E        CMPNE   Not equal

0x3         DCMPULT Unsigned less than (64-bit)

0x3F        CMPULE  Unsigned less than or equal (64-bit)

0x3E        CMPGE   Greater than or equal (signed)

0x4         DCMPLT  Less than (signed)

0x6D        CMPLE   Less than or equal (signed)

0x6F        CMPUGE  Unsigned greater than or equal

*/



void ExecuteStage::executeIntegerArithmetic(const DecodedInstruction &instruction)

{

    quint64 raValue = (instruction.ra == 31) ? 0 : m_cpu->getRegister(instruction.ra);

    quint64 rbValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);



    // Handle immediate mode

    if (instruction.rawInstruction & 0x1000) // Bit 12 = immediate mode

    {

        rbValue = instruction.immediate;

    }



    quint64 result = 0;

    bool overflow = false;

    bool trapOnOverflow = (instruction.function & FUNC_ADDLV) != 0; // V bit in function code



    /*

    All overflow-trap variants (bit 6 = 1) fall through to the “Unimplemented INTA function”

    path because no matching case labels are present, even though the generic overflow check exists.

    */

    switch (instruction.function)

    {

    case FUNC_ADDL:  // ADDL

    case FUNC_ADDLV: // ADDL/V

    {

        qint32 a = static_cast<qint32>(raValue);

        qint32 b = static_cast<qint32>(rbValue);

        qint64 res64 = static_cast<qint64>(a) + static_cast<qint64>(b);

        qint32 res32 = static_cast<qint32>(res64);



        result = static_cast<quint64>(static_cast<qint64>(res32)); // Sign-extend

        overflow = (res64 != static_cast<qint64>(res32));



        DEBUG_LOG(QString("ExecuteStage: %1 %2 + %3 = %4")

                      .arg((trapOnOverflow) ? "ADDL/V" : "ADDL")

                      .arg(a)

                      .arg(b)

                      .arg(res32));

        break;

    }



    case FUNC_S4ADDL:  // S4ADDL        // Confirmed

    case FUNC_S4ADDLV: // S4ADDL/V      // integer-operate format. Base S4ADDL is function 0x02; adding bit 6 (+0x40)

                       // gives the “/V” overflow-checked variant 0x42.

    {

        qint32 a = static_cast<qint32>(raValue);

        qint32 b = static_cast<qint32>(rbValue);

        qint64 res64 = (static_cast<qint64>(a) << 2) + static_cast<qint64>(b);

        qint32 res32 = static_cast<qint32>(res64);



        result = static_cast<quint64>(static_cast<qint64>(res32));

        overflow = (res64 != static_cast<qint64>(res32));



        DEBUG_LOG(QString("ExecuteStage: %1 (%2 << 2) + %3 = %4")

                      .arg((trapOnOverflow) ? "S4ADDL/V" : "S4ADDL")

                      .arg(a)

                      .arg(b)

                      .arg(res32));

        break;

    }



    case FUNC_SUBL:  // SUBL

    case FUNC_SUBLV: // SUBL/V  Set bit 6 (OR with 0x40): 0x09 | 0x40 = 0x49 → SUBL/V

    {

        qint32 a = static_cast<qint32>(raValue);

        qint32 b = static_cast<qint32>(rbValue);

        qint64 res64 = static_cast<qint64>(a) - static_cast<qint64>(b);

        qint32 res32 = static_cast<qint32>(res64);



        result = static_cast<quint64>(static_cast<qint64>(res32));

        overflow = (res64 != static_cast<qint64>(res32));



        DEBUG_LOG(QString("ExecuteStage: %1 %2 - %3 = %4")

                      .arg((trapOnOverflow) ? "SUBL/V" : "SUBL")

                      .arg(a)

                      .arg(b)

                      .arg(res32));

        break;

    }



    case FUNC_S4SUBL:  // S4SUBL

    case FUNC_S4SUBLV: // S4SUBL/V  Set bit 6 (OR with 0x40): 0x0B | 0x40 = 0x4B → S4SUBL/V

    {

        qint32 a = static_cast<qint32>(raValue);

        qint32 b = static_cast<qint32>(rbValue);

        qint64 res64 = (static_cast<qint64>(a) << 2) - static_cast<qint64>(b);

        qint32 res32 = static_cast<qint32>(res64);



        result = static_cast<quint64>(static_cast<qint64>(res32));

        overflow = (res64 != static_cast<qint64>(res32));



        DEBUG_LOG(QString("ExecuteStage: %1 (%2 << 2) - %3 = %4")

                      .arg((trapOnOverflow) ? "S4SUBL/V" : "S4SUBL")

                      .arg(a)

                      .arg(b)

                      .arg(res32));

        break;

    }

    case FUNC_CMPBGE: // CMPBGE

    {

        // Compare bytes greater than or equal

        result = 0;

        for (int i = 0; i < 8; i++)

        {

            quint8 aByte = (raValue >> (i * 8)) & 0xFF;

            quint8 bByte = (rbValue >> (i * 8)) & 0xFF;

            if (aByte >= bByte)

            {

                result |= (1ULL << i);

            }

        }

        DEBUG_LOG(QString("ExecuteStage: CMPBGE result = 0x%1").arg(result, 2, 16, QChar('0')));

        break;

    }

    case FUNC_S8ADDL:  // S8ADDL

    case FUNC_S8ADDLV: // S8ADDL/V Set bit 6 (OR with 0x40): 0x12 | 0x40 = 0x52 → S8SUBL/V

    {

        qint32 a = static_cast<qint32>(raValue);

        qint32 b = static_cast<qint32>(rbValue);

        qint64 res64 = (static_cast<qint64>(a) << 3) + static_cast<qint64>(b);

        qint32 res32 = static_cast<qint32>(res64);



        result = static_cast<quint64>(static_cast<qint64>(res32));

        overflow = (res64 != static_cast<qint64>(res32));



        DEBUG_LOG(QString("ExecuteStage: %1 (%2 << 3) + %3 = %4")

                      .arg((trapOnOverflow) ? "S8ADDL/V" : "S8ADDL")

                      .arg(a)

                      .arg(b)

                      .arg(res32));

        break;

    }



    case FUNC_S8SUBL:  // S8SUBL

    case FUNC_S8SUBLV: // S8SUBL/V *** ADDED ***

    {

        qint32 a = static_cast<qint32>(raValue);

        qint32 b = static_cast<qint32>(rbValue);

        qint64 res64 = (static_cast<qint64>(a) << 3) - static_cast<qint64>(b);

        qint32 res32 = static_cast<qint32>(res64);



        result = static_cast<quint64>(static_cast<qint64>(res32));

        overflow = (res64 != static_cast<qint64>(res32));



        DEBUG_LOG(QString("ExecuteStage: %1 (%2 << 3) - %3 = %4")

                      .arg((trapOnOverflow) ? "S8SUBL/V" : "S8SUBL")

                      .arg(a)

                      .arg(b)

                      .arg(res32));

        break;

    }



    case FUNC_CMPULT_L:

    {

        quint32 a = static_cast<quint32>(raValue);

        quint32 b = static_cast<quint32>(rbValue);

        result = (a < b) ? 1 : 0;

        break;

    }



    case FUNC_CMPULT_G:

    {

        result = (raValue < rbValue) ? 1 : 0;

        break;

    }



    case FUNC_CMPULE_L:

    case FUNC_CMPULE_G: // CMPULE

    {



        if (instruction.function & 0x20)

        { // quad-word path

            result = (raValue <= rbValue) ? 1 : 0;

        }

        else

        { // long-word path

            result = (static_cast<quint32>(raValue) <= static_cast<quint32>(rbValue)) ? 1 : 0;

        }

        break;

        DEBUG_LOG(QString("ExecuteStage: CMPULE (longword) %1 <= %2 ? %3").arg(raValue).arg(rbValue).arg(result));

        break;

    }



    // ========== Quadword Operations ==========

    case FUNC_ADDQ:  // ADDQ

    case FUNC_ADDQV: // ADDQ/V *** ADDED ***

    {

        // For quadword operations, check overflow is more complex

        quint64 oldResult = result;

        result = raValue + rbValue;



        // Check for overflow in addition

        overflow = ((raValue ^ result) & (rbValue ^ result)) >> 63;



        DEBUG_LOG(QString("ExecuteStage: %1 0x%2 + 0x%3 = 0x%4")

                      .arg((trapOnOverflow) ? "ADDQ/V" : "ADDQ")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }



    case FUNC_S4ADDQ:  // S4ADDQ *** ADDED ***

    case FUNC_S4ADDQV: // S4ADDQ/V *** ADDED ***

    {

        quint64 shiftedRA = raValue << 2;

        result = shiftedRA + rbValue;



        // Check for overflow

        overflow = (shiftedRA > result) || ((raValue & 0xC000000000000000ULL) != 0);



        DEBUG_LOG(QString("ExecuteStage: %1 (0x%2 << 2) + 0x%3 = 0x%4")

                      .arg((trapOnOverflow) ? "S4ADDQ/V" : "S4ADDQ")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }

    case FUNC_SUBQ:  // SUBQ

    case FUNC_SUBQV: // SUBQ/V *** ADDED ***

    {

        result = raValue - rbValue;



        // Check for underflow

        overflow = (raValue < rbValue);



        DEBUG_LOG(QString("ExecuteStage: %1 0x%2 - 0x%3 = 0x%4")

                      .arg((trapOnOverflow) ? "SUBQ/V" : "SUBQ")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }

    case FUNC_S4SUBQ:  // S4SUBQ *** ADDED ***

    case FUNC_S4SUBQV: // S4SUBQ/V *** ADDED ***

    {

        quint64 shiftedRA = raValue << 2;

        result = shiftedRA - rbValue;



        // Check for underflow

        overflow = (shiftedRA < rbValue);



        DEBUG_LOG(QString("ExecuteStage: %1 (0x%2 << 2) - 0x%3 = 0x%4")

                      .arg((trapOnOverflow) ? "S4SUBQ/V" : "S4SUBQ")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }



    case FUNC_CMPEQ: // CMPEQ

    {

        result = (raValue == rbValue) ? 1 : 0;

        DEBUG_LOG(QString("ExecuteStage: CMPEQ 0x%1 == 0x%2 ? %3")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result));

        break;

    }

    case FUNC_CMPNE: // CMPNE Synthesized to (CMEQ, XOR)

    {

        result = (raValue != rbValue) ? 1 : 0;

        DEBUG_LOG(QString("ExecuteStage - Synthesized to (CMEQ, XOR): CMPNE 0x%1 != 0x%2 ? %3")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result));

        break;

    }



    case FUNC_S8ADDQ:  // S8ADDQ *** ADDED ***

    case FUNC_S8ADDQV: // S8ADDQ/V *** ADDED ***

    {

        quint64 shiftedRA = raValue << 3;

        result = shiftedRA + rbValue;



        // Check for overflow

        overflow = (shiftedRA > result) || ((raValue & 0xE000000000000000ULL) != 0);



        DEBUG_LOG(QString("ExecuteStage: %1 (0x%2 << 3) + 0x%3 = 0x%4")

                      .arg((trapOnOverflow) ? "S8ADDQ/V" : "S8ADDQ")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }



    case FUNC_S8SUBQ:  // S8SUBQ *** ADDED ***

    case FUNC_S8SUBQV: // S8SUBQ/V *** ADDED ***

    {

        quint64 shiftedRA = raValue << 3;

        result = shiftedRA - rbValue;



        // Check for underflow

        overflow = (shiftedRA < rbValue);



        DEBUG_LOG(QString("ExecuteStage: %1 (0x%2 << 3) - 0x%3 = 0x%4")

                      .arg((trapOnOverflow) ? "S8SUBQ/V" : "S8SUBQ")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }



    case FUNC_CMPULT_L:

    { // unsigned < (long-word)

        quint32 a = static_cast<quint32>(raValue);

        quint32 b = static_cast<quint32>(rbValue);

        result = (a < b) ? 1 : 0;

        break;

    }



    case FUNC_CMPULT_G:

    { // unsigned < (quad-word)

        result = (raValue < rbValue) ? 1 : 0;

        break;

    }



    case FUNC_CMPGEQ: // CMPGE (signed)

    {

        qint64 a = static_cast<qint64>(raValue);

        qint64 b = static_cast<qint64>(rbValue);

        result = (a >= b) ? 1 : 0;

        DEBUG_LOG(QString("ExecuteStage: CMPGE (signed) %1 >= %2 ? %3").arg(a).arg(b).arg(result));

        break;

    }



    case FUNC_CMPLT: // CMPLT (signed longword)

    {

        quint32 a = static_cast<quint32>(raValue);

        quint32 b = static_cast<quint32>(rbValue);

        result = (a < b) ? 1 : 0;

        DEBUG_LOG(QString("ExecuteStage: CMPLT (longword) %1 < %2 ? %3").arg(a).arg(b).arg(result));

        break;

    }

        //     case 0x4D: // CMPLT

        //     {

        //         result = (static_cast<qint64>(raValue) < static_cast<qint64>(rbValue)) ? 1 : 0;

        //         DEBUG_LOG(QString("ExecuteStage: CMPLT (signed) result = %1").arg(result));

        //         break;

        //     }



        //     case 0x6D: // CMPLE Less than or equal (signed)

        //     {

        //         qint32 a = static_cast<qint32>(raValue);

        //         qint32 b = static_cast<qint32>(rbValue);

        //         result = (a <= b) ? 1 : 0;

        //         DEBUG_LOG(QString("ExecuteStage: CMPLE (signed longword) %1 <= %2 ? %3").arg(a).arg(b).arg(result));

        //         break;

        //     }

    case FUNC_CMPLE: // CMPLE (Quadword) Less than or equal (signed)

    {

        result = (static_cast<qint64>(raValue) <= static_cast<qint64>(rbValue)) ? 1 : 0;

        DEBUG_LOG(QString("ExecuteStage: CMPLE (signed) result = %1").arg(result));

        break;

    }



    case FUNC_CMPUGE: // CMPUGE *** ADDED ***

    {

        result = (raValue >= rbValue) ? 1 : 0;

        DEBUG_LOG(QString("ExecuteStage: CMPUGE 0x%1 >= 0x%2 ? %3")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result));

        break;

    }



    default:

        DEBUG_LOG(

            QString("ExecuteStage: Unimplemented INTA function 0x%1").arg(instruction.function, 2, 16, QChar('0')));

        m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

        return;

    }



    // Store result

    if (instruction.rc != 31)

    {

        m_cpu->setRegister(instruction.rc, result);

    }



    // Handle overflow trap variants (functions with bit 6 set)

    if (overflow && (instruction.function & 0x40))

    {

        m_cpu->triggerException(AlphaCPU::ARITHMETIC_TRAP, m_cpu->getPC());

    }

}



void ExecuteStage::executeIntegerLogical(const DecodedInstruction &instruction)

{

    quint64 raValue = (instruction.ra == 31) ? 0 : m_cpu->getRegister(instruction.ra);

    quint64 rbValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);



    // Handle immediate mode

    if (instruction.rawInstruction & 0x1000)

    {

        rbValue = instruction.immediate;

    }



    quint64 result = 0;



    switch (instruction.function)

    {

    case FUNC_AND: // AND

    {

        result = raValue & rbValue;

        DEBUG_LOG(QString("ExecuteStage: AND 0x%1 & 0x%2 = 0x%3")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }

    case FUNC_BIC: // BIC (Bit Clear)

    {

        result = raValue & ~rbValue;

        DEBUG_LOG(QString("ExecuteStage: BIC 0x%1 & ~0x%2 = 0x%3")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }

    case FUNC_BIS: // BIS (OR)

    {

        result = raValue | rbValue;

        DEBUG_LOG(QString("ExecuteStage: BIS 0x%1 | 0x%2 = 0x%3")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }

    case FUNC_XOR: // XOR

    {

        result = raValue ^ rbValue;

        DEBUG_LOG(QString("ExecuteStage: XOR 0x%1 ^ 0x%2 = 0x%3")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }

    case FUNC_EQV: // EQV (Equivalence - NOT XOR)

    {

        result = ~(raValue ^ rbValue);

        DEBUG_LOG(QString("ExecuteStage: EQV ~(0x%1 ^ 0x%2) = 0x%3")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }

    case FUNC_ORNOT: // ORNOT

    {

        result = raValue | ~rbValue;

        DEBUG_LOG(QString("ExecuteStage: ORNOT 0x%1 | ~0x%2 = 0x%3")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }

    // Conditional move instructions

    case FUNC_CMOVLBS: // CMOVLBS - Move if Low Bit Set

    {

        result = (raValue & 1) ? rbValue : m_cpu->getRegister(instruction.rc);

        DEBUG_LOG(QString("ExecuteStage: CMOVLBS %1").arg((raValue & 1) ? "moved" : "not moved"));

        break;

    }

    case FUNC_CMOVLBC: // CMOVLBC - Move if Low Bit Clear

    {

        result = (raValue & 1) ? m_cpu->getRegister(instruction.rc) : rbValue;

        DEBUG_LOG(QString("ExecuteStage: CMOVLBC %1").arg((raValue & 1) ? "not moved" : "moved"));

        break;

    }

    case FUNC_CMOVEQ: // CMOVEQ - Move if Equal to zero

    {

        result = (raValue == 0) ? rbValue : m_cpu->getRegister(instruction.rc);

        DEBUG_LOG(QString("ExecuteStage: CMOVEQ %1").arg((raValue == 0) ? "moved" : "not moved"));

        break;

    }

    case FUNC_CMOVNE: // CMOVNE - Move if Not Equal to zero

    {

        result = (raValue != 0) ? rbValue : m_cpu->getRegister(instruction.rc);

        DEBUG_LOG(QString("ExecuteStage: CMOVNE %1").arg((raValue != 0) ? "moved" : "not moved"));

        break;

    }

    case FUNC_CMOVLT: // CMOVLT - Move if Less Than zero (signed)

    {

        result = (static_cast<qint64>(raValue) < 0) ? rbValue : m_cpu->getRegister(instruction.rc);

        DEBUG_LOG(QString("ExecuteStage: CMOVLT %1").arg((static_cast<qint64>(raValue) < 0) ? "moved" : "not moved"));

        break;

    }

    case FUNC_CMOVGE: // CMOVGE - Move if Greater than or Equal to zero (signed)

    {

        result = (static_cast<qint64>(raValue) >= 0) ? rbValue : m_cpu->getRegister(instruction.rc);

        DEBUG_LOG(QString("ExecuteStage: CMOVGE %1").arg((static_cast<qint64>(raValue) >= 0) ? "moved" : "not moved"));

        break;

    }

    case FUNC_CMOVLE: // CMOVLE - Move if Less than or Equal to zero (signed)

    {

        result = (static_cast<qint64>(raValue) <= 0) ? rbValue : m_cpu->getRegister(instruction.rc);

        DEBUG_LOG(QString("ExecuteStage: CMOVLE %1").arg((static_cast<qint64>(raValue) <= 0) ? "moved" : "not moved"));

        break;

    }



    case FUNC_CMOVGT: // CMOVGT - Move if Greater Than zero (signed)

    {

        result = (static_cast<qint64>(raValue) > 0) ? rbValue : m_cpu->getRegister(instruction.rc);

        DEBUG_LOG(QString("ExecuteStage: CMOVGT %1").arg((static_cast<qint64>(raValue) > 0) ? "moved" : "not moved"));

        break;

    }

    // Architecture-specific instructions

    case FUNC_AMASK: // AMASK - Architecture Mask

    {

        // Return implemented architecture features

        // This is implementation-specific

        result = ~0ULL; // Indicate all features unimplemented (conservative)

        DEBUG_LOG("ExecuteStage: AMASK returning 0xFFFFFFFFFFFFFFFF");

        break;

    }

    case FUNC_IMPLVER:

    { // IMPLVER

        // Whatever source of “implementation version” you track:

        //   0 = EV4, 1 = EV5, 2 = EV6, 3 = EV7 …  or any value you choose.

        quint64 implVer = m_cpu->implVersion(); // e.g. returns 1 for EV5

        result = implVer;                       // no overflow possible

        DEBUG_LOG(QString("ExecuteStage: IMPLVER → %1").arg(implVer));

        break;

    }

    case FUNC_MSKBL: // MSKBL - Mask Byte Low

    case FUNC_EXTBL: // EXTBL - Extract Byte Low

    case FUNC_INSBL: // INSBL - Insert Byte Low

    case FUNC_MSKWL: // MSKWL - Mask Word Low

    case FUNC_EXTWL: // EXTWL - Extract Word Low

    case FUNC_INSWL: // INSWL - Insert Word Low

    case FUNC_MSKLL: // MSKLL - Mask Longword Low

    case FUNC_EXTLL: // EXTLL - Extract Longword Low

    case FUNC_INSLL: // INSLL - Insert Longword Low

    case FUNC_MSKQL: // MSKQL - Mask Quadword Low

    case FUNC_EXTQL: // EXTQL - Extract Quadword Low

    case FUNC_INSQL: // INSQL - Insert Quadword Low

    case FUNC_MSKWH: // MSKWH - Mask Word High

    case FUNC_INSWH: // INSWH - Insert Word High

    case FUNC_EXTWH: // EXTWH - Extract Word High

    case FUNC_MSKLH: // MSKLH - Mask Longword High

    case FUNC_INSLH: // INSLH - Insert Longword High

    case FUNC_EXTLH: // EXTLH - Extract Longword High

    case FUNC_MSKQH: // MSKQH - Mask Quadword High

    case FUNC_INSQH: // INSQH - Insert Quadword High

    case FUNC_EXTQH: // EXTQH - Extract Quadword High

    {

        // Implementation for mask/insert/extract instructions

        break;

    }

    default:

        DEBUG_LOG(

            QString("ExecuteStage: Unimplemented INTL function 0x%1").arg(instruction.function, 2, 16, QChar('0')));

        m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

        return;

    }



    // Store result

    if (instruction.rc != 31)

    {

        m_cpu->setRegister(instruction.rc, result);

    }

}



void ExecuteStage::executeConditionalBranch(const DecodedInstruction &instruction)

{

    quint64 raValue = (instruction.ra == 31) ? 0 : m_cpu->getRegister(instruction.ra);

    bool takeBranch = false;

    QString conditionName;



    switch (instruction.opcode)

    {

    case OPCODE_BEQ: // BEQ - Branch if Equal

        takeBranch = (raValue == 0);

        conditionName = "BEQ";

        break;



    case OPCODE_BNE: // BNE - Branch if Not Equal

        takeBranch = (raValue != 0);

        conditionName = "BNE";

        break;



    case OPCODE_BLT: // BLT - Branch if Less Than

        takeBranch = (static_cast<qint64>(raValue) < 0);

        conditionName = "BLT";

        break;



    case OPCODE_BGE: // BGE - Branch if Greater than or Equal

        takeBranch = (static_cast<qint64>(raValue) >= 0);

        conditionName = "BGE";

        break;



    case OPCODE_BLE: // BLE - Branch if Less than or Equal

        takeBranch = (static_cast<qint64>(raValue) <= 0);

        conditionName = "BLE";

        break;



    case OPCODE_BGT: // BGT - Branch if Greater Than

        takeBranch = (static_cast<qint64>(raValue) > 0);

        conditionName = "BGT";

        break;

    }



    if (takeBranch)

    {

        quint64 currentPC = m_cpu->getPC();

        quint64 targetPC = currentPC + instruction.immediate;

        m_cpu->setPC(targetPC);

        m_cpu->flushPipeline(); // Branch taken - flush pipeline



        DEBUG_LOG(

            QString("ExecuteStage: %1 taken, jumping to 0x%2").arg(conditionName).arg(targetPC, 16, 16, QChar('0')));

    }

    else

    {

        DEBUG_LOG(QString("ExecuteStage: %1 not taken").arg(conditionName));

    }

}



void ExecuteStage::executeBranch(const DecodedInstruction &instruction)

{

    quint64 currentPC = m_cpu->getPC();

    quint64 targetPC = currentPC + instruction.immediate;



    switch (instruction.opcode)

    {

    case OPCODE_BR: // BR - Unconditional Branch

    {

        // Store return address in Ra if not R31

        if (instruction.ra != 31)

        {

            m_cpu->setRegister(instruction.ra, currentPC + 4);

        }



        m_cpu->setPC(targetPC);

        m_cpu->flushPipeline();



        DEBUG_LOG(QString("ExecuteStage: BR to 0x%1, return address in R%2")

                      .arg(targetPC, 16, 16, QChar('0'))

                      .arg(instruction.ra));

        break;

    }



    case OPCODE_BSR: // BSR - Branch to Subroutine

    {

        // Always store return address (even if Ra is 31)

        if (instruction.ra != 31)

        {

            m_cpu->setRegister(instruction.ra, currentPC + 4);

        }



        m_cpu->setPC(targetPC);

        m_cpu->flushPipeline();



        DEBUG_LOG(QString("ExecuteStage: BSR to 0x%1, return address 0x%2 in R%3")

                      .arg(targetPC, 16, 16, QChar('0'))

                      .arg(currentPC + 4, 16, 16, QChar('0'))

                      .arg(instruction.ra));

        break;

    }

    }

}



void ExecuteStage::executeBitTestBranch(const DecodedInstruction &instruction)

{

    quint64 raValue = (instruction.ra == 31) ? 0 : m_cpu->getRegister(instruction.ra);

    bool takeBranch = false;

    QString conditionName;



    switch (instruction.opcode)

    {

    case OPCODE_BLBC: // BLBC - Branch if Low Bit Clear

        takeBranch = ((raValue & 1) == 0);

        conditionName = "BLBC";

        break;



    case OPCODE_BLBS: // BLBS - Branch if Low Bit Set

        takeBranch = ((raValue & 1) == 1);

        conditionName = "BLBS";

        break;

    }



    if (takeBranch)

    {

        quint64 currentPC = m_cpu->getPC();

        quint64 targetPC = currentPC + instruction.immediate;

        m_cpu->setPC(targetPC);

        m_cpu->flushPipeline();



        DEBUG_LOG(QString("ExecuteStage: %1 taken (bit = %2), jumping to 0x%3")

                      .arg(conditionName)

                      .arg(raValue & 1)

                      .arg(targetPC, 16, 16, QChar('0')));

    }

    else

    {

        DEBUG_LOG(QString("ExecuteStage: %1 not taken (bit = %2)").arg(conditionName).arg(raValue & 1));

    }

}



void ExecuteStage::executeJump(const DecodedInstruction &instruction)

{

    quint64 raValue = (instruction.ra == 31) ? 0 : m_cpu->getRegister(instruction.ra);

    quint64 rbValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);

    quint64 currentPC = m_cpu->getPC();



    // Calculate target address

    quint64 targetPC = (rbValue + (instruction.immediate & 0x3FFF)) & ~0x3ULL; // Align to 4 bytes



    switch (instruction.function)

    {

    case 0: // JMP

    {

        // Store PC+4 in Ra (prediction base for returns)

        if (instruction.ra != 31)

        {

            m_cpu->setRegister(instruction.ra, currentPC + 4);

        }



        m_cpu->setPC(targetPC);

        m_cpu->flushPipeline();



        DEBUG_LOG(QString("ExecuteStage: JMP to 0x%1 (Ra=%2)").arg(targetPC, 16, 16, QChar('0')).arg(instruction.ra));

        break;

    }



    case 1: // JSR - Jump to Subroutine

    {

        // Store return address in Ra

        if (instruction.ra != 31)

        {

            m_cpu->setRegister(instruction.ra, currentPC + 4);

        }



        m_cpu->setPC(targetPC);

        m_cpu->flushPipeline();



        // Push return address onto hardware return stack (if implemented)

        m_cpu->pushReturnStack(currentPC + 4);



        DEBUG_LOG(QString("ExecuteStage: JSR to 0x%1, return address 0x%2")

                      .arg(targetPC, 16, 16, QChar('0'))

                      .arg(currentPC + 4, 16, 16, QChar('0')));

        break;

    }



    case 2: // RET - Return from Subroutine

    {

        // Pop return address from hardware return stack (if implemented)

        quint64 predictedReturn = m_cpu->popReturnStack();



        // Store PC+4 in Ra (usually not used for RET)

        if (instruction.ra != 31)

        {

            m_cpu->setRegister(instruction.ra, currentPC + 4);

        }



        m_cpu->setPC(targetPC);

        m_cpu->flushPipeline();



        DEBUG_LOG(QString("ExecuteStage: RET to 0x%1 (predicted: 0x%2)")

                      .arg(targetPC, 16, 16, QChar('0'))

                      .arg(predictedReturn, 16, 16, QChar('0')));



        // Check if prediction was correct

        if (targetPC != predictedReturn)

        {

            DEBUG_LOG("ExecuteStage: Return stack misprediction detected");

            m_cpu->incrementReturnMispredictions();

        }

        break;

    }



    case 3: // JSR_COROUTINE

    {

        // Coroutine jump - similar to JSR but for coroutines

        if (instruction.ra != 31)

        {

            m_cpu->setRegister(instruction.ra, currentPC + 4);

        }



        m_cpu->setPC(targetPC);

        m_cpu->flushPipeline();



        DEBUG_LOG(QString("ExecuteStage: JSR_COROUTINE to 0x%1").arg(targetPC, 16, 16, QChar('0')));

        break;

    }



    default:

    {

        DEBUG_LOG(QString("ExecuteStage: Unknown jump function %1").arg(instruction.function));

        m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, currentPC);

        break;

    }

    }

}



void ExecuteStage::executeIntegerShift(const DecodedInstruction &instruction)

{

    quint64 raValue = (instruction.ra == 31) ? 0 : m_cpu->getRegister(instruction.ra);

    quint64 rbValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);



    // Handle immediate mode

    if (instruction.rawInstruction & 0x1000)

    {

        rbValue = instruction.immediate;

    }



    quint64 result = 0;

    quint32 shiftAmount = rbValue & 0x3F; // Only lower 6 bits used for shift amount



    switch (instruction.function)

    {

    case FUNC_SLL: // SLL - Shift Left Logical

        result = raValue << shiftAmount;

        DEBUG_LOG(QString("ExecuteStage: SLL 0x%1 << %2 = 0x%3")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(shiftAmount)

                      .arg(result, 16, 16, QChar('0')));

        break;



    case FUNC_SRA: // SRA - Shift Right Arithmetic

        result = static_cast<quint64>(static_cast<qint64>(raValue) >> shiftAmount);

        DEBUG_LOG(QString("ExecuteStage: SRA 0x%1 >> %2 = 0x%3 (arithmetic)")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(shiftAmount)

                      .arg(result, 16, 16, QChar('0')));

        break;



    case FUNC_SRL: // SRL - Shift Right Logical

        result = raValue >> shiftAmount;

        DEBUG_LOG(QString("ExecuteStage: SRL 0x%1 >> %2 = 0x%3 (logical)")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(shiftAmount)

                      .arg(result, 16, 16, QChar('0')));

        break;



    case FUNC_EXTBL: // EXTBL - Extract Byte Low

    {

        quint32 bytePos = shiftAmount & 0x7; // Only lower 3 bits

        result = (raValue >> (bytePos * 8)) & 0xFF;

        DEBUG_LOG(QString("ExecuteStage: EXTBL byte %1 from 0x%2 = 0x%3")

                      .arg(bytePos)

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(result, 2, 16, QChar('0')));

        break;

    }



    case OPCODE_FLTI: // EXTWL - Extract Word Low

    {

        quint32 wordPos = (shiftAmount >> 1) & 0x3; // Word position

        result = (raValue >> (wordPos * 16)) & 0xFFFF;

        DEBUG_LOG(QString("ExecuteStage: EXTWL word %1 from 0x%2 = 0x%3")

                      .arg(wordPos)

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(result, 4, 16, QChar('0')));

        break;

    }



    case FUNC_EXTLL: // EXTLL - Extract Longword Low

    {

        quint32 longwordPos = (shiftAmount >> 2) & 0x1; // Longword position

        result = (raValue >> (longwordPos * 32)) & 0xFFFFFFFF;

        // Sign-extend result to 64 bits

        result = static_cast<quint64>(static_cast<qint64>(static_cast<qint32>(result)));

        DEBUG_LOG(QString("ExecuteStage: EXTLL longword %1 from 0x%2 = 0x%3")

                      .arg(longwordPos)

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(result, 8, 16, QChar('0')));

        break;

    }



    case FUNC_EXTQL: // EXTQL - Extract Quadword Low

    {

        // For quadword, shift amount determines byte boundary

        result = raValue >> ((shiftAmount & 0x7) * 8);

        DEBUG_LOG(QString("ExecuteStage: EXTQL from 0x%1 shift %2 = 0x%3")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(shiftAmount & 0x7)

                      .arg(result, 16, 16, QChar('0')));

        break;

    }



    case FUNC_SRL: // SRL - Shift Right Logical

    case FUNC_SLL: // SLL - Shift Left Logical

    case FUNC_SRA: // SRA - Shift Right Arithmetic

    {

        // Implementation for shift instructions

        break;

    }



    default:

    {

        DEBUG_LOG(

            QString("ExecuteStage: Unimplemented INTS function 0x%1").arg(instruction.function, 2, 16, QChar('0')));

        m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

        return;

    }

    }



    // Store result

    if (instruction.rc != 31)

    {

        m_cpu->setRegister(instruction.rc, result);

    }

}



void ExecuteStage::executeIntegerMultiply(const DecodedInstruction &instruction)

{

    quint64 raValue = (instruction.ra == 31) ? 0 : m_cpu->getRegister(instruction.ra);

    quint64 rbValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);



    // Handle immediate mode

    if (instruction.rawInstruction & 0x1000)

    {

        rbValue = instruction.immediate;

    }



    quint64 result = 0;



    switch (instruction.function)

    {

    case FUNC_MULL:

    case FUNC_MULL_V:

    {

        qint64 prod =

            static_cast<qint64>(static_cast<qint32>(raValue)) * static_cast<qint64>(static_cast<qint32>(rbValue));



        result = static_cast<quint64>(static_cast<qint32>(prod)); // sign-extend 32-bit low part

        overflow = ((instruction.function & 0x40) != 0) &&

                   ((prod >> 31) != (prod >> 63)); // true if high 32 bits ≠ sign of low 32

        break;

    }



    case FUNC_MULQ:

    case FUNC_MULQV:

    {

        // 64-bit signed multiply

#if defined(__GNUC__) || defined(__clang__)

        __int128 prod128 =

            static_cast<__int128>(static_cast<qint64>(raValue)) * static_cast<__int128>(static_cast<qint64>(rbValue));

        quint64 prod64 = static_cast<quint64>(prod128); // low 64 bits

#else

        /* portable fallback: multiply via 32-bit halves or use a helper */

        quint64 prod64 = raValue * rbValue; // lose high part – OK for result

        bool lost_hi = true;                // assume overflow test below fails

#endif



        result = prod64;



        // Overflow test for /V form: high 64 bits must be sign-extension

#if defined(__GNUC__) || defined(__clang__)

        qint64 hi = static_cast<qint64>(prod128 >> 64);

        qint64 sext_of_low = static_cast<qint64>(prod64) >> 63;

        overflow = (hi != sext_of_low);

#else

        overflow = false; // if you can’t compute the high part, omit /V support

#endif



        DEBUG_LOG(QString("ExecuteStage: %1 0x%2 * 0x%3 -> 0x%4")

                      .arg((instruction.function & 0x40) ? "MULQ/V" : "MULQ")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }



    case FUNC_UMULH: // UMULH - Unsigned Multiply High

    {

        // Multiply and return upper 64 bits

        __uint128_t fullResult = static_cast<__uint128_t>(raValue) * static_cast<__uint128_t>(rbValue);

        result = static_cast<quint64>(fullResult >> 64);



        DEBUG_LOG(QString("ExecuteStage: UMULH 0x%1 * 0x%2 = 0x%3 (high)")

                      .arg(raValue, 16, 16, QChar('0'))

                      .arg(rbValue, 16, 16, QChar('0'))

                      .arg(result, 16, 16, QChar('0')));

        break;

    }



    case FUNC_MULL:   // MULL - Multiply Longword

    case FUNC_MULQ:   // MULQ - Multiply Quadword

    case FUNC_UMULH:  // UMULH - Unsigned Multiply High

    case FUNC_MULL_V: // MULL/V - Multiply Longword with overflow

    case FUNC_MULQ_V: // MULQ/V - Multiply Quadword with overflow

    {

        // Implementation for multiply instructions

        break;

    }



    default:

    {

        DEBUG_LOG(

            QString("ExecuteStage: Unimplemented INTM function 0x%1").arg(instruction.function, 2, 16, QChar('0')));

        m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

        return;

    }

    }



    // Store result

    if (instruction.rc != 31)

    {

        m_cpu->setRegister(instruction.rc, result);

    }

}



#ifdef ALPHA_PLATFORM_TRU64

// Tru64/Digital UNIX capabilities

void ExecuteStage::executePAL(const DecodedInstruction &instruction)

{

    // PAL (Privileged Architecture Library) calls

    // These are system calls and privileged operations



    quint32 palFunction = instruction.function & 0x3FFFFFF;



    DEBUG_LOG(QString("ExecuteStage: PAL call 0x%1").arg(palFunction, 6, 16, QChar('0')));



    // Check if in kernel mode

    if (!m_cpu->isKernelMode())

    {

        DEBUG_LOG("ExecuteStage: PAL call in user mode - triggering privilege violation");

        m_cpu->triggerException(AlphaCPU::PRIVILEGE_VIOLATION, m_cpu->getPC());

        return;

    }



    // Common PAL functions (OpenVMS/Digital UNIX style)

    switch (palFunction)

    {

    case PalOpcodes::Common::PAL_HALT: // HALT

        DEBUG_LOG("ExecuteStage: PAL HALT");

        m_cpu->halt();

        break;



    case PalOpcodes::Common::PAL_CFLUSH: // CFLUSH - Cache Flush

        DEBUG_LOG("ExecuteStage: PAL CFLUSH");

        m_cpu->flushCaches();

        break;



    case PalOpcodes::Common::PAL_DRAINA: // DRAINA - Drain Aborts

        DEBUG_LOG("ExecuteStage: PAL DRAINA");

        m_cpu->drainAborts();

        break;



    case PalOpcodes::Tru64::PAL_CSERVE: // CSERVE - Console Service

        DEBUG_LOG("ExecuteStage: PAL CSERVE");

        m_cpu->executeConsoleService();

        break;



    case PalOpcodes::Tru64::PAL_MTPR_IPIR: // WRIPIR - Write Interprocessor Interrupt Request

        DEBUG_LOG("ExecuteStage: PAL WRIPIR");

        m_cpu->writeIPIR(m_cpu->getRegister(16)); // R16 contains processor mask

        break;



    case PalOpcodes::Tru64::PAL_RDMCES: // RDMCES - Read Machine Check Error Summary

    {                // Read Machine-Check Error Summary

        DEBUG_LOG("ExecuteStage: PAL RDMCES");

        m_cpu->setRegister(0, m_cpu->readMCES());

        break;

    }



    case PalOpcodes::Tru64::PAL_WRMCES: // WRMCES - Write Machine Check Error Summary

        DEBUG_LOG("ExecuteStage: PAL WRMCES");

        m_cpu->writeMCES(m_cpu->getRegister(16)); // R16 contains value

        break;



    case PalOpcodes::Tru64::PAL_WRFEN: // WRFEN - Write Floating-Point Enable

        DEBUG_LOG("ExecuteStage: PAL WRFEN");

        m_cpu->writeFEN(m_cpu->getRegister(16) & 1); // R16 contains enable bit

        break;



    case PalOpcodes::Tru64::PAL_SWPIRQL: // SWPIRQL - Swap IRQ Level

        DEBUG_LOG("ExecuteStage: PAL SWPIRQL");

        {

            quint64 newLevel = m_cpu->getRegister(16) & 0x1F; // R16 contains new level

            quint64 oldLevel = m_cpu->swapIRQL(newLevel);

            if (0 != 31) // Store old level in R0

            {

                m_cpu->setRegister(0, oldLevel);

            }

        }

        break;



    case PalOpcodes::Tru64::PAL_RDIRQL: // RDIRQL - Read IRQ Level

        DEBUG_LOG("ExecuteStage: PAL RDIRQL");

        if (0 != 31) // Store current IRQL in R0

        {

            m_cpu->setRegister(0, m_cpu->readIRQL());

        }

        break;



    case PalOpcodes::Tru64::PAL_DI: // DI - Disable Interrupts

        DEBUG_LOG("ExecuteStage: PAL DI");

        m_cpu->disableInterrupts();

        break;



    case PalOpcodes::Tru64::PAL_EI: // EI - Enable Interrupts

        DEBUG_LOG("ExecuteStage: PAL EI");

        m_cpu->enableInterrupts();

        break;



    case PalOpcodes::Tru64::PAL_SWPPAL: // SWPPAL - Swap PAL Base

        DEBUG_LOG("ExecuteStage: PAL SWPPAL");

        {

            quint64 newBase = m_cpu->getRegister(16); // R16 contains new PAL base

            quint64 oldBase = m_cpu->swapPALBase(newBase);

            if (0 != 31) // Store old base in R0

            {

                m_cpu->setRegister(0, oldBase);

            }

        }

        break;



    case PalOpcodes::Tru64::PAL_WRVPTPTR: // WRVPTPTR - Write Virtual Page Table Pointer

        DEBUG_LOG("ExecuteStage: PAL WRVPTPTR");

        m_cpu->writeVPTPtr(m_cpu->getRegister(16)); // R16 contains pointer

        break;



    case PalOpcodes::Tru64::PAL_WTKTRP: // WTKTRP - Write TLB Trap

        DEBUG_LOG("ExecuteStage: PAL WTKTRP");

        m_cpu->writeTLBTrap(m_cpu->getRegister(16)); // R16 contains trap address

        break;



    case PalOpcodes::Tru64::PAL_SWPCTX: // SWPCTX - Swap Process Context

        DEBUG_LOG("ExecuteStage: PAL SWPCTX");

        {

            quint64 newContext = m_cpu->getRegister(16); // R16 contains new PCB address

            quint64 oldContext = m_cpu->swapContext(newContext);

            if (0 != 31) // Store old context in R0

            {

                m_cpu->setRegister(0, oldContext);

            }

        }

        break;



        case PalOpcodes::Tru64::PAL_TODO_IMB:

        {

        DEBUG_LOG("ExecuteStage Tru64: TODO: IMB");

        } 

        break;

        case PalOpcodes::Tru64::PAL_TODO_RDPERFMON:

        {

            DEBUG_LOG("ExecuteStage Tru64: TODO: RDPERFMON");

        }

        break;

        case PalOpcodes::Tru64::PAL_WRVAL: // WRVAL - Write Virtual Address Cache

        DEBUG_LOG("ExecuteStage: PAL WRVAL");

        m_cpu->writeVAL(m_cpu->getRegister(16)); // R16 contains value

        break;



    case PalOpcodes::Tru64::PAL_RDVAL: // RDVAL - Read Virtual Address Cache

        DEBUG_LOG("ExecuteStage: PAL RDVAL");

        if (0 != 31) // Store VAL in R0

        {

            m_cpu->setRegister(0, m_cpu->readVAL());

        }

        break;



    case PalOpcodes::Tru64::PAL_TBI: // TBI - TB Invalidate

        DEBUG_LOG("ExecuteStage: PAL TBI");

        {

            quint64 type = m_cpu->getRegister(16);    // R16 contains invalidation type

            quint64 address = m_cpu->getRegister(17); // R17 contains address

            m_cpu->invalidateTB(type, address);

        }

        break;



    case PalOpcodes::Tru64::PAL_WRENT: // WRENT - Write System Entry Address

        DEBUG_LOG("ExecuteStage: PAL WRENT");

        {

            quint64 address = m_cpu->getRegister(16); // R16 contains entry address

            quint64 type = m_cpu->getRegister(17);    // R17 contains entry type

            m_cpu->writeSystemEntry(address, type);

        }

        break;



    case PalOpcodes::Tru64::PAL_RDPS: // RDPS - Read Processor Status

        DEBUG_LOG("ExecuteStage: PAL RDPS");

        if (0 != 31) // Store PS in R0

        {

            m_cpu->setRegister(0, m_cpu->readProcessorStatus());

        }

        break;



    case PalOpcodes::Tru64::PAL_WRKGP: // WRKGP - Write Kernel Global Pointer

        DEBUG_LOG("ExecuteStage: PAL WRKGP");

        m_cpu->writeKGP(m_cpu->getRegister(16)); // R16 contains KGP value

        break;



    case PalOpcodes::Tru64::PAL_WRUSP: // PAL_WRUSP - Write User Stack Pointer

        DEBUG_LOG("ExecuteStage: PAL WRUSP");

        m_cpu->writeUSP(m_cpu->getRegister(16)); // R16 contains USP value

        break;



    case PalOpcodes::Tru64::PAL_WRPERFMON: // PAL_WRPERFMON - Write Performance Monitor

        DEBUG_LOG("ExecuteStage: PAL WRPERFMON");

        {

            quint64 function = m_cpu->getRegister(16); // R16 contains function

            quint64 value = m_cpu->getRegister(17);    // R17 contains value

            m_cpu->writePerfMon(function, value);

        }

        break;



    case PalOpcodes::Tru64::PAL_RDUSP: // RDUSP - Read User Stack Pointer

        DEBUG_LOG("ExecuteStage: PAL RDUSP");

        if (0 != 31) // Store USP in R0

        {

            m_cpu->setRegister(0, m_cpu->readUSP());

        }

        break;



    default:

        DEBUG_LOG(QString("ExecuteStage: Unknown PAL function 0x%1").arg(palFunction, 6, 16, QChar('0')));

        m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

        break;

    }

}

#endif

#ifdef ALPHA_PLATFORM_OPENVMS





void ExecuteStage::executePAL(const DecodedInstruction &instruction)

{

    // PAL (Privileged Architecture Library) calls

    // These are system calls and privileged operations

    quint32 palFunction = instruction.function & 0x3FFFFFF;

    DEBUG_LOG(QString("ExecuteStage: PAL call 0x%1").arg(palFunction, 6, 16, QChar('0')));



    // Check if in kernel mode

    if (!m_cpu->isKernelMode())

    {

        DEBUG_LOG("ExecuteStage: PAL call in user mode - triggering privilege violation");

        m_cpu->triggerException(ExceptionType::PRIVILEGE_VIOLATION, m_cpu->getPC());

        return;

    }



    // Common PAL functions for all platforms

    switch (palFunction)

    {

    case PalOpcodes::Common::PAL_HALT: // HALT

        DEBUG_LOG("ExecuteStage: PAL HALT");

        m_cpu->halt();

        break;

    case PalOpcodes::Common::PAL_CFLUSH: // CFLUSH - Cache Flush

        DEBUG_LOG("ExecuteStage: PAL CFLUSH");

        m_cpu->flushCaches();

        break;

    case PalOpcodes::Common::PAL_DRAINA: // DRAINA - Drain Aborts

        DEBUG_LOG("ExecuteStage: PAL DRAINA");

        m_cpu->drainAborts();

        break;



    // OpenVMS-specific PAL functions

    case PalOpcodes::OpenVMS::PAL_SWPCTX: // Swap context

        DEBUG_LOG("ExecuteStage: PAL SWPCTX");

        {

            quint64 newContext = m_cpu->getRegister(16); // R16 contains new PCB address

            quint64 oldContext = m_cpu->swapContext(newContext);

            if (0 != 31) // Store old context in R0

            {

                m_cpu->setRegister(0, oldContext);

            }

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_ASN: // Move from processor register - ASN

        DEBUG_LOG("ExecuteStage: PAL MFPR_ASN");

        if (0 != 31) // Store ASN in R0

        {

            m_cpu->setRegister(0, m_cpu->readASN());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_ASTEN: // Move to processor register - AST enable

        DEBUG_LOG("ExecuteStage: PAL MTPR_ASTEN");

        m_cpu->writeASTEN(m_cpu->getRegister(16)); // R16 contains value

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_ASTSR: // Move to processor register - AST summary

        DEBUG_LOG("ExecuteStage: PAL MTPR_ASTSR");

        m_cpu->writeASTSR(m_cpu->getRegister(16)); // R16 contains value

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_FEN: // Move from processor register - FP enable

        DEBUG_LOG("ExecuteStage: PAL MFPR_FEN");

        if (0 != 31) // Store FEN in R0

        {

            m_cpu->setRegister(0, m_cpu->readFEN());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_FEN: // Move to processor register - FP enable

        DEBUG_LOG("ExecuteStage: PAL MTPR_FEN");

        m_cpu->writeFEN(m_cpu->getRegister(16) & 1); // R16 contains enable bit

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_IPIR: // Move to processor register - IPI request

        DEBUG_LOG("ExecuteStage: PAL MTPR_IPIR");

        m_cpu->writeIPIR(m_cpu->getRegister(16)); // R16 contains processor mask

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_IPL: // Move from processor register - IPL

        DEBUG_LOG("ExecuteStage: PAL MFPR_IPL");

        if (0 != 31) // Store IPL in R0

        {

            m_cpu->setRegister(0, m_cpu->readIRQL());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_IPL: // Move to processor register - IPL

        DEBUG_LOG("ExecuteStage: PAL MTPR_IPL");

        {

            quint64 newLevel = m_cpu->getRegister(16) & 0x1F; // R16 contains new level

            quint64 oldLevel = m_cpu->swapIRQL(newLevel);

            if (0 != 31) // Store old level in R0

            {

                m_cpu->setRegister(0, oldLevel);

            }

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_MCES: // Move from processor register - MCES

        DEBUG_LOG("ExecuteStage: PAL MFPR_MCES");

        if (0 != 31) // Store MCES in R0

        {

            m_cpu->setRegister(0, m_cpu->readMCES());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_MCES: // Move to processor register - MCES

        DEBUG_LOG("ExecuteStage: PAL MTPR_MCES");

        m_cpu->writeMCES(m_cpu->getRegister(16)); // R16 contains value

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_PCBB: // Move from processor register - PCBB

        DEBUG_LOG("ExecuteStage: PAL MFPR_PCBB");

        if (0 != 31) // Store PCBB in R0

        {

            m_cpu->setRegister(0, m_cpu->readPCBB());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_PRBR: // Move from processor register - PRBR

        DEBUG_LOG("ExecuteStage: PAL MFPR_PRBR");

        if (0 != 31) // Store PRBR in R0

        {

            m_cpu->setRegister(0, m_cpu->readPRBR());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_PRBR: // Move to processor register - PRBR

        DEBUG_LOG("ExecuteStage: PAL MTPR_PRBR");

        m_cpu->writePRBR(m_cpu->getRegister(16)); // R16 contains value

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_PTBR: // Move from processor register - PTBR

        DEBUG_LOG("ExecuteStage: PAL MFPR_PTBR");

        if (0 != 31) // Store PTBR in R0

        {

            m_cpu->setRegister(0, m_cpu->readPTBR());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_SCBB: // Move from processor register - SCBB

        DEBUG_LOG("ExecuteStage: PAL MFPR_SCBB");

        if (0 != 31) // Store SCBB in R0

        {

            m_cpu->setRegister(0, m_cpu->readSCBB());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_SCBB: // Move to processor register - SCBB

        DEBUG_LOG("ExecuteStage: PAL MTPR_SCBB");

        m_cpu->writeSCBB(m_cpu->getRegister(16)); // R16 contains value

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_SIRR: // Move to processor register - SIRR

        DEBUG_LOG("ExecuteStage: PAL MTPR_SIRR");

        m_cpu->writeSIRR(m_cpu->getRegister(16)); // R16 contains value

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_SISR: // Move from processor register - SISR

        DEBUG_LOG("ExecuteStage: PAL MFPR_SISR");

        if (0 != 31) // Store SISR in R0

        {

            m_cpu->setRegister(0, m_cpu->readSISR());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_TBCHK: // Move from processor register - TBCHK

        DEBUG_LOG("ExecuteStage: PAL MFPR_TBCHK");

        if (0 != 31) // Store TBCHK result in R0

        {

            quint64 address = m_cpu->getRegister(16); // R16 contains address to check

            m_cpu->setRegister(0, m_cpu->checkTB(address));

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_TBIA: // Move to processor register - TBIA

        DEBUG_LOG("ExecuteStage: PAL MTPR_TBIA");

        m_cpu->invalidateTBAll();

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_TBIAP: // Move to processor register - TBIAP

        DEBUG_LOG("ExecuteStage: PAL MTPR_TBIAP");

        m_cpu->invalidateTBAllProcess();

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_TBIS: // Move to processor register - TBIS

        DEBUG_LOG("ExecuteStage: PAL MTPR_TBIS");

        m_cpu->invalidateTBSingle(m_cpu->getRegister(16)); // R16 contains address

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_ESP: // Move from processor register - ESP

        DEBUG_LOG("ExecuteStage: PAL MFPR_ESP");

        if (0 != 31) // Store ESP in R0

        {

            m_cpu->setRegister(0, m_cpu->readESP());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_ESP: // Move to processor register - ESP

        DEBUG_LOG("ExecuteStage: PAL MTPR_ESP");

        m_cpu->writeESP(m_cpu->getRegister(16)); // R16 contains value

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_SSP: // Move from processor register - SSP

        DEBUG_LOG("ExecuteStage: PAL MFPR_SSP");

        if (0 != 31) // Store SSP in R0

        {

            m_cpu->setRegister(0, m_cpu->readSSP());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_SSP: // Move to processor register - SSP

        DEBUG_LOG("ExecuteStage: PAL MTPR_SSP");

        m_cpu->writeSSP(m_cpu->getRegister(16)); // R16 contains value

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_USP: // Move from processor register - USP

        DEBUG_LOG("ExecuteStage: PAL MFPR_USP");

        if (0 != 31) // Store USP in R0

        {

            m_cpu->setRegister(0, m_cpu->readUSP());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_USP: // Move to processor register - USP

        DEBUG_LOG("ExecuteStage: PAL MTPR_USP");

        m_cpu->writeUSP(m_cpu->getRegister(16)); // R16 contains value

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_TBISD: // Move to processor register - TBISD

        DEBUG_LOG("ExecuteStage: PAL MTPR_TBISD");

        m_cpu->invalidateTBSingleData(m_cpu->getRegister(16)); // R16 contains address

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_TBISI: // Move to processor register - TBISI

        DEBUG_LOG("ExecuteStage: PAL MTPR_TBISI");

        m_cpu->invalidateTBSingleInst(m_cpu->getRegister(16)); // R16 contains address

        break;

    case PalOpcodes::OpenVMS::MFPR_ASTEN: // Move from processor register - ASTEN

        DEBUG_LOG("ExecuteStage: PAL MFPR_ASTEN");

        if (0 != 31) // Store ASTEN in R0

        {

            m_cpu->setRegister(0, m_cpu->readASTEN());

        }

        break;

    case PalOpcodes::OpenVMS::MFPR_ASTSR: // Move from processor register - ASTSR

        DEBUG_LOG("ExecuteStage: PAL MFPR_ASTSR");

        if (0 != 31) // Store ASTSR in R0

        {

            m_cpu->setRegister(0, m_cpu->readASTSR());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_VPTB: // Move from processor register - VPTB

        DEBUG_LOG("ExecuteStage: PAL MFPR_VPTB");

        if (0 != 31) // Store VPTB in R0

        {

            m_cpu->setRegister(0, m_cpu->readVPTB());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_VPTB: // Move to processor register - VPTB

        DEBUG_LOG("ExecuteStage: PAL MTPR_VPTB");

        m_cpu->writeVPTB(m_cpu->getRegister(16)); // R16 contains value

        break;

    case PalOpcodes::OpenVMS::PAL_MTPR_PERFMON: // Move to processor register - PERFMON

        DEBUG_LOG("ExecuteStage: PAL MTPR_PERFMON");

        {

            quint64 function = m_cpu->getRegister(16); // R16 contains function

            quint64 value = m_cpu->getRegister(17);    // R17 contains value

            m_cpu->writePerfMon(function, value);

        }

        break;

    case PalOpcodes::OpenVMS::PAL_MFPR_WHAMI: // Move from processor register - WHAMI

        DEBUG_LOG("ExecuteStage: PAL MFPR_WHAMI");

        if (0 != 31) // Store WHAMI in R0

        {

            m_cpu->setRegister(0, m_cpu->readWHAMI());

        }

        break;

    case PalOpcodes::OpenVMS::PAL_CHME: // Change mode to executive

        DEBUG_LOG("ExecuteStage: PAL CHME");

        m_cpu->changeMode(AlphaCPU::MODE_EXECUTIVE);

        break;

    case PalOpcodes::OpenVMS::PAL_CHMS: // Change mode to supervisor

        DEBUG_LOG("ExecuteStage: PAL CHMS");

        m_cpu->changeMode(AlphaCPU::MODE_SUPERVISOR);

        break;

    case PalOpcodes::OpenVMS::PAL_CHMU: // Change mode to user

        DEBUG_LOG("ExecuteStage: PAL CHMU");

        m_cpu->changeMode(AlphaCPU::MODE_USER);

        break;

    case PalOpcodes::OpenVMS::PAL_INSQHIL: // Insert into queue head, longword, interlocked

        DEBUG_LOG("ExecuteStage: PAL INSQHIL");

        {

            quint64 queue = m_cpu->getRegister(16); // R16 contains queue header address

            quint64 entry = m_cpu->getRegister(17); // R17 contains entry address

            quint64 result = m_cpu->insertQueueHeadLW(queue, entry);

            if (0 != 31) // Store result in R0

            {

                m_cpu->setRegister(0, result);

            }

        }

        break;

    case PalOpcodes::OpenVMS::PAL_INSQTIL: // Insert into queue tail, longword, interlocked

        DEBUG_LOG("ExecuteStage: PAL INSQTIL");

        {

            quint64 queue = m_cpu->getRegister(16); // R16 contains queue header address

            quint64 entry = m_cpu->getRegister(17); // R17 contains entry address

            quint64 result = m_cpu->insertQueueTailLW(queue, entry);

            if (0 != 31) // Store result in R0

            {

                m_cpu->setRegister(0, result);

            }

        }

        break;

    case PalOpcodes::OpenVMS::PAL_INSQHIQ: // Insert into queue head, quadword, interlocked

        DEBUG_LOG("ExecuteStage: PAL INSQHIQ");

        {

            quint64 queue = m_cpu->getRegister(16); // R16 contains queue header address

            quint64 entry = m_cpu->getRegister(17); // R17 contains entry address

            quint64 result = m_cpu->insertQueueHeadQW(queue, entry);

            if (0 != 31) // Store result in R0

            {

                m_cpu->setRegister(0, result);

            }

        }

        break;

    case PalOpcodes::OpenVMS::PAL_INSQTIQ: // Insert into queue tail, quadword, interlocked

        DEBUG_LOG("ExecuteStage: PAL INSQTIQ");

        {

            quint64 queue = m_cpu->getRegister(16); // R16 contains queue header address

            quint64 entry = m_cpu->getRegister(17); // R17 contains entry address

            quint64 result = m_cpu->insertQueueTailQW(queue, entry);

            if (0 != 31) // Store result in R0

            {

                m_cpu->setRegister(0, result);

            }

        }

        break;

    case PalOpcodes::OpenVMS::PAL_REMQHIL: // Remove from queue head, longword, interlocked

        DEBUG_LOG("ExecuteStage: PAL REMQHIL");

        {

            quint64 queue = m_cpu->getRegister(16); // R16 contains queue header address

            quint64 address, result;

            result = m_cpu->removeQueueHeadLW(queue, &address);

            if (0 != 31) // Store result in R0

            {

                m_cpu->setRegister(0, result);

            }

            // R2 receives the address of the removed entry

            m_cpu->setRegister(2, address);

        }

        break;

    case PalOpcodes::OpenVMS::PAL_REMQTIL: // Remove from queue tail, longword, interlocked

        DEBUG_LOG("ExecuteStage: PAL REMQTIL");

        {

            quint64 queue = m_cpu->getRegister(16); // R16 contains queue header address

            quint64 address, result;

            result = m_cpu->removeQueueTailLW(queue, &address);

            if (0 != 31) // Store result in R0

            {

                m_cpu->setRegister(0, result);

            }

            // R2 receives the address of the removed entry

            m_cpu->setRegister(2, address);

        }

        break;

    case PalOpcodes::OpenVMS::PAL_REMQHIQ: // Remove from queue head, quadword, interlocked

        DEBUG_LOG("ExecuteStage: PAL REMQHIQ");

        {

            quint64 queue = m_cpu->getRegister(16); // R16 contains queue header address

            quint64 address, result;

            result = m_cpu->removeQueueHeadQW(queue, &address);

            if (0 != 31) // Store result in R0

            {

                m_cpu->setRegister(0, result);

            }

            // R2 receives the address of the removed entry

            m_cpu->setRegister(2, address);

        }

        break;

    case PalOpcodes::OpenVMS::PAL_REMQTIQ: // Remove from queue tail, quadword, interlocked

        DEBUG_LOG("ExecuteStage: PAL REMQTIQ");

        {

            quint64 queue = m_cpu->getRegister(16); // R16 contains queue header address

            quint64 address, result;

            result = m_cpu->removeQueueTailQW(queue, &address);

            if (0 != 31) // Store result in R0

            {

                m_cpu->setRegister(0, result);

            }

            // R2 receives the address of the removed entry

            m_cpu->setRegister(2, address);

        }

        break;

    default:

        DEBUG_LOG(QString("ExecuteStage: Unknown PAL function 0x%1").arg(palFunction, 6, 16, QChar('0')));

        m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

        break;

    }

}



#endif





// Forward declaration for floating point methods

void ExecuteStage::executeFloatingPointLoad(const DecodedInstruction &instruction)

{

    // Calculate effective address

    quint64 baseValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);

    quint64 effectiveAddress = baseValue + instruction.immediate;



    DEBUG_LOG(QString("ExecuteStage: FP Load from EA=0x%1").arg(effectiveAddress, 16, 16, QChar('0')));



    switch (instruction.opcode)

    {

    case OPCODE_LDF: // LDF - Load F_floating (32-bit VAX format)

    case OPCODE_LDS: // LDS - Load S_floating (32-bit IEEE format)

    {

        quint32 value;

        if (m_cpu->readMemory32(effectiveAddress, value))

        {

            // Store in floating-point register

            m_cpu->setFloatRegister(instruction.ra, value);

            DEBUG_LOG(QString("ExecuteStage: %1 F%2 = 0x%3")

                          .arg(instruction.opcode == 0x20 ? "LDF" : "LDS")

                          .arg(instruction.ra)

                          .arg(value, 8, 16, QChar('0')));

        }

        else

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        break;

    }



    case OPCODE_LDG: // LDG - Load G_floating (64-bit VAX format)

    case OPCODE_LDT: // LDT - Load T_floating (64-bit IEEE format)

    {

        quint64 value;

        if (m_cpu->readMemory64(effectiveAddress, value))

        {

            // Store in floating-point register

            m_cpu->setFloatRegister(instruction.ra, value);

            DEBUG_LOG(QString("ExecuteStage: %1 F%2 = 0x%3")

                          .arg(instruction.opcode == 0x21 ? "LDG" : "LDT")

                          .arg(instruction.ra)

                          .arg(value, 16, 16, QChar('0')));

        }

        else

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        break;

    }

    }

}



void ExecuteStage::executeFloatingPointStore(const DecodedInstruction &instruction)

{

    // Calculate effective address

    quint64 baseValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);

    quint64 effectiveAddress = baseValue + instruction.immediate;



    DEBUG_LOG(QString("ExecuteStage: FP Store to EA=0x%1").arg(effectiveAddress, 16, 16, QChar('0')));



    switch (instruction.opcode)

    {

    case OPCODE_STF: // STF - Store F_floating (32-bit VAX format)

    case OPCODE_STS: // STS - Store S_floating (32-bit IEEE format)

    {

        quint32 value = m_cpu->getFloatRegister32(instruction.ra);

        if (!m_cpu->writeMemory32(effectiveAddress, value))

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        DEBUG_LOG(QString("ExecuteStage: %1 F%2 (0x%3) stored")

                      .arg(instruction.opcode == 0x24 ? "STF" : "STS")

                      .arg(instruction.ra)

                      .arg(value, 8, 16, QChar('0')));

        break;

    }



    case OPCODE_STG: // STG - Store G_floating (64-bit VAX format)

    case OPCODE_STT: // STT - Store T_floating (64-bit IEEE format)

    {

        quint64 value = m_cpu->getFloatRegister64(instruction.ra);

        if (!m_cpu->writeMemory64(effectiveAddress, value))

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        DEBUG_LOG(QString("ExecuteStage: %1 F%2 (0x%3) stored")

                      .arg(instruction.opcode == 0x25 ? "STG" : "STT")

                      .arg(instruction.ra)

                      .arg(value, 16, 16, QChar('0')));

        break;

    }

    }

}

void ExecuteStage::executeFloatingPointBranch(const DecodedInstruction &instruction)

{

    quint64 faValue = m_cpu->getFloatRegister64(instruction.ra);

    bool takeBranch = false;

    QString conditionName;



    switch (instruction.opcode)

    {

    case OPCODE_FBEQ: // FBEQ - Floating Branch if Equal

        // Check if floating-point value equals zero

        takeBranch = m_cpu->isFloatZero(faValue);

        conditionName = "FBEQ";

        break;



    case OPCODE_FBLT: // FBLT - Floating Branch if Less Than

        // Check if floating-point value is less than zero

        takeBranch = m_cpu->isFloatNegative(faValue) && !m_cpu->isFloatZero(faValue);

        conditionName = "FBLT";

        break;



    case OPCODE_FBLE: // FBLE - Floating Branch if Less Than or Equal

        // Check if floating-point value is less than or equal to zero

        takeBranch = m_cpu->isFloatNegative(faValue) || m_cpu->isFloatZero(faValue);

        conditionName = "FBLE";

        break;



    case OPCODE_FBNE: // FBNE - Floating Branch if Not Equal

        // Check if floating-point value is not zero

        takeBranch = !m_cpu->isFloatZero(faValue);

        conditionName = "FBNE";

        break;



    case OPCODE_FBGE: // FBGE - Floating Branch if Greater Than or Equal

        // Check if floating-point value is greater than or equal to zero

        takeBranch = !m_cpu->isFloatNegative(faValue);

        conditionName = "FBGE";

        break;



    case OPCODE_FBGT: // FBGT - Floating Branch if Greater Than

        // Check if floating-point value is greater than zero

        takeBranch = !m_cpu->isFloatNegative(faValue) && !m_cpu->isFloatZero(faValue);

        conditionName = "FBGT";

        break;

    }



    if (takeBranch)

    {

        quint64 currentPC = m_cpu->getPC();

        quint64 targetPC = currentPC + instruction.immediate;

        m_cpu->setPC(targetPC);

        m_cpu->flushPipeline();



        DEBUG_LOG(

            QString("ExecuteStage: %1 taken, jumping to 0x%2").arg(conditionName).arg(targetPC, 16, 16, QChar('0')));

    }

    else

    {

        DEBUG_LOG(QString("ExecuteStage: %1 not taken").arg(conditionName));

    }

}



void ExecuteStage::executeLoadUnaligned(const DecodedInstruction &instruction)

{

    // Calculate effective address

    quint64 baseValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);

    quint64 effectiveAddress = baseValue + instruction.immediate;



    DEBUG_LOG(QString("ExecuteStage: Unaligned load from EA=0x%1").arg(effectiveAddress, 16, 16, QChar('0')));



    switch (instruction.opcode)

    {

    case OPCODE_LDBU: // LDBU - Load Byte Unsigned

    {

        quint8 value;

        if (ldq_u(effectiveAddress, value))

        {

            if (instruction.ra != 31)

            {

                m_cpu->setRegister(instruction.ra, static_cast<quint64>(value));

            }

            DEBUG_LOG(QString("ExecuteStage: LDBU R%1 = 0x%2").arg(instruction.ra).arg(value, 2, 16, QChar('0')));

        }

        else

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        break;

    }



    case OPCODE_LDWU: // LDWU - Load Word Unsigned

    {

        quint16 value;

        if (m_cpu->readMemory16(effectiveAddress, value))

        {

            if (instruction.ra != 31)

            {

                m_cpu->setRegister(instruction.ra, static_cast<quint64>(value));

            }

            DEBUG_LOG(QString("ExecuteStage: LDWU R%1 = 0x%2").arg(instruction.ra).arg(value, 4, 16, QChar('0')));

        }

        else

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        break;

    }



    case OPCODE_LDQ_U: // LDQ_U - Load Quadword Unaligned

    {

        // Alpha LDQ_U loads from quadword boundary, ignoring low 3 bits of address

        quint64 alignedAddress = effectiveAddress & ~0x7ULL;

        quint64 value;

        if (m_cpu->readMemory64(alignedAddress, value))

        {

            if (instruction.ra != 31)

            {

                m_cpu->setRegister(instruction.ra, value);

            }

            DEBUG_LOG(QString("ExecuteStage: LDQ_U R%1 = 0x%2 (from aligned 0x%3)")

                          .arg(instruction.ra)

                          .arg(value, 16, 16, QChar('0'))

                          .arg(alignedAddress, 16, 16, QChar('0')));

        }

        else

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, alignedAddress);

        }

        break;

    }

    }

}



void ExecuteStage::executeStoreUnaligned(const DecodedInstruction &instruction)

{

    // Calculate effective address

    quint64 baseValue = (instruction.rb == 31) ? 0 : m_cpu->getRegister(instruction.rb);

    quint64 effectiveAddress = baseValue + instruction.immediate;

    quint64 storeValue = (instruction.ra == 31) ? 0 : m_cpu->getRegister(instruction.ra);



    DEBUG_LOG(QString("ExecuteStage: Unaligned store to EA=0x%1, value=0x%2")

                  .arg(effectiveAddress, 16, 16, QChar('0'))

                  .arg(storeValue, 16, 16, QChar('0')));



    switch (instruction.opcode)

    {

    case OPCODE_STB: // STB - Store Byte

    {

        quint8 value = static_cast<quint8>(storeValue);

        if (!m_cpu->writeMemory8(effectiveAddress, value))

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        DEBUG_LOG(QString("ExecuteStage: STB stored 0x%1").arg(value, 2, 16, QChar('0')));

        break;

    }



    case OPCODE_STW: // STW - Store Word

    {

        quint16 value = static_cast<quint16>(storeValue);

        if (!m_cpu->writeMemory16(effectiveAddress, value))

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, effectiveAddress);

        }

        DEBUG_LOG(QString("ExecuteStage: STW stored 0x%1").arg(value, 4, 16, QChar('0')));

        break;

    }



    case OPCODE_STQ_U: // STQ_U - Store Quadword Unaligned

    {

        // Alpha STQ_U stores to quadword boundary, ignoring low 3 bits of address

        quint64 alignedAddress = effectiveAddress & ~0x7ULL;



        // For unaligned store, we need to read-modify-write

        // This is a simplified implementation - real Alpha would use byte masks

        quint64 currentValue;

        if (m_cpu->readMemory64(alignedAddress, currentValue))

        {

            // Calculate byte offset within quadword

            quint32 offset = effectiveAddress & 0x7;

            quint64 mask = 0xFFULL << (offset * 8);

            quint64 shiftedValue = (storeValue & 0xFF) << (offset * 8);



            quint64 newValue = (currentValue & ~mask) | (shiftedValue & mask);



            if (!m_cpu->writeMemory64(alignedAddress, newValue))

            {

                m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, alignedAddress);

            }

            DEBUG_LOG(QString("ExecuteStage: STQ_U stored byte 0x%1 at offset %2 (result: 0x%3)")

                          .arg(storeValue & 0xFF, 2, 16, QChar('0'))

                          .arg(offset)

                          .arg(newValue, 16, 16, QChar('0')));

        }

        else

        {

            m_cpu->triggerException(AlphaCPU::MEMORY_ACCESS_FAULT, alignedAddress);

        }

        break;

    }

    }

}



void ExecuteStage::executeIntegerToFloat(const DecodedInstruction &instruction)

{

    // ITFP - Integer to Floating-Point conversions

    quint64 raValue = (instruction.ra == 31) ? 0 : m_cpu->getRegister(instruction.ra);

    quint64 result = 0;



    switch (instruction.function)

    {

    case OPCODE_RESERVED04: // ITOFS - Integer to F_floating Single

    {

        qint32 intValue = static_cast<qint32>(raValue);

        result = m_cpu->convertToFFormat(intValue);

        DEBUG_LOG(QString("ExecuteStage: ITOFS %1 -> F%2").arg(intValue).arg(instruction.rc));

        break;

    }



    case OPCODE_LDBU: // ITOFF - Integer to F_floating

    {

        qint64 intValue = static_cast<qint64>(raValue);

        result = m_cpu->convertToFFormat(intValue);

        DEBUG_LOG(QString("ExecuteStage: ITOFF %1 -> F%2").arg(intValue).arg(instruction.rc));

        break;

    }



    case OPCODE_LDWU: // ITOFT - Integer to T_floating

    {

        qint64 intValue = static_cast<qint64>(raValue);

        result = m_cpu->convertToTFormat(intValue);

        DEBUG_LOG(QString("ExecuteStage: ITOFT %1 -> F%2").arg(intValue).arg(instruction.rc));

        break;

    }



    case OPCODE_ITFP: // ITOFS/U - Integer to F_floating Single (unsigned)

    {

        quint32 intValue = static_cast<quint32>(raValue);

        result = m_cpu->convertToFFormat(intValue);

        DEBUG_LOG(QString("ExecuteStage: ITOFS/U %1 -> F%2").arg(intValue).arg(instruction.rc));

        break;

    }



    case OPCODE_JSR: // ITOFF/U - Integer to F_floating (unsigned)

    {

        result = m_cpu->convertToFFormat(raValue);

        DEBUG_LOG(QString("ExecuteStage: ITOFF/U %1 -> F%2").arg(raValue).arg(instruction.rc));

        break;

    }



    case OPCODE_RESERVED1C: // ITOFT/U - Integer to T_floating (unsigned)

    {

        result = m_cpu->convertToTFormat(raValue);

        DEBUG_LOG(QString("ExecuteStage: ITOFT/U %1 -> F%2").arg(raValue).arg(instruction.rc));

        break;

    }



    default:

        DEBUG_LOG(

            QString("ExecuteStage: Unimplemented ITFP function 0x%1").arg(instruction.function, 2, 16, QChar('0')));

        m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

        return;

    }



    // Store result in floating-point register

    if (instruction.rc != 31)

    {

        m_cpu->setFloatRegister(instruction.rc, result);

    }

}



void ExecuteStage::executeFloatingPointOperate(const DecodedInstruction &instruction)

{

    // Get floating-point operands

    quint64 faValue = m_cpu->getFloatRegister64(instruction.ra);

    quint64 fbValue = m_cpu->getFloatRegister64(instruction.rb);

    quint64 result = 0;



    // Check for floating-point exceptions enabled

    if (!m_cpu->isFloatingPointEnabled())

    {

        DEBUG_LOG("ExecuteStage: Floating-point operation with FP disabled");

        m_cpu->triggerException(AlphaCPU::FLOATING_POINT_DISABLED, m_cpu->getPC());

        return;

    }



    switch (instruction.opcode)

    {

    case OPCODE_FLTV: // FLTV - VAX Floating-Point

    {

        switch (instruction.function)

        {

        case FUNC_ADDF: // ADDF - Add F_floating

            result = m_cpu->addFFormat(faValue, fbValue);

            DEBUG_LOG("ExecuteStage: ADDF");

            break;



        case FUNC_SUBF: // SUBF - Subtract F_floating

            result = m_cpu->subFFormat(faValue, fbValue);

            DEBUG_LOG("ExecuteStage: SUBF");

            break;



        case FUNC_MULF: // MULF - Multiply F_floating

            result = m_cpu->mulFFormat(faValue, fbValue);

            DEBUG_LOG("ExecuteStage: MULF");

            break;



        case FUNC_DIVF: // DIVF - Divide F_floating

            result = m_cpu->divFFormat(faValue, fbValue);

            DEBUG_LOG("ExecuteStage: DIVF");

            break;



        case FUNC_CVTFQ: // CVTFQ - Convert F_floating to Quadword

            result = m_cpu->convertFToQuad(faValue);

            DEBUG_LOG("ExecuteStage: CVTFQ");

            break;



        case FUNC_CMPFEQ: // CMPFEQ - Compare F_floating Equal

            result = m_cpu->compareFFormat(faValue, fbValue, AlphaCPU::FP_EQUAL);

            DEBUG_LOG("ExecuteStage: CMPFEQ");

            break;



        case FUNC_CMPFLT: // CMPFLT - Compare F_floating Less Than

            result = m_cpu->compareFFormat(faValue, fbValue, AlphaCPU::FP_LESS);

            DEBUG_LOG("ExecuteStage: CMPFLT");

            break;



        case FUNC_CMPFLE: // CMPFLE - Compare F_floating Less Than or Equal

            result = m_cpu->compareFFormat(faValue, fbValue, AlphaCPU::FP_LESS_EQUAL);

            DEBUG_LOG("ExecuteStage: CMPFLE");

            break;



        case FUNC_ITOFS: // ITOFS - Integer to F_floating Single

        {

            float result = static_cast<float>(static_cast<int32_t>(raValue));

            m_cpu->setFloatRegister(instruction.rc, result);

            DEBUG_LOG(QString("ExecuteStage: ITOFS R%1 (%2) -> F%3 (%4)")

                          .arg(instruction.ra)

                          .arg(static_cast<int32_t>(raValue))

                          .arg(instruction.rc)

                          .arg(result));

            break;

        }



        case FUNC_ITOFF: // ITOFF - Integer to F_floating

        {

            double result = static_cast<double>(static_cast<int64_t>(raValue));

            m_cpu->setFloatRegister(instruction.rc, result);

            DEBUG_LOG(QString("ExecuteStage: ITOFF R%1 (%2) -> F%3 (%4)")

                          .arg(instruction.ra)

                          .arg(static_cast<int64_t>(raValue))

                          .arg(instruction.rc)

                          .arg(result));

            break;

        }



        case FUNC_ITOFT: // ITOFT - Integer to T_floating

        {

            double result = static_cast<double>(static_cast<int64_t>(raValue));

            m_cpu->setFloatRegister(instruction.rc, result);

            DEBUG_LOG(QString("ExecuteStage: ITOFT R%1 (%2) -> F%3 (%4)")

                          .arg(instruction.ra)

                          .arg(static_cast<int64_t>(raValue))

                          .arg(instruction.rc)

                          .arg(result));

            break;

        }



        case FUNC_SQRTF:   // SQRTF - Square Root F_floating

        case FUNC_SQRTG:   // SQRTG - Square Root G_floating

        case FUNC_SQRTS:   // SQRTS - Square Root S_floating

        case FUNC_SQRTT:   // SQRTT - Square Root T_floating

        case FUNC_SQRTF_C: // SQRTF/C - Square Root F_floating (Chopped)

        case FUNC_SQRTG_C: // SQRTG/C - Square Root G_floating (Chopped)

        case FUNC_SQRTS_C: // SQRTS/C - Square Root S_floating (Chopped)

        case FUNC_SQRTT_C: // SQRTT/C - Square Root T_floating (Chopped)

        case FUNC_SQRTS_M: // SQRTS/M - Square Root S_floating (Round to Minus Infinity)

        case FUNC_SQRTT_M: // SQRTT/M - Square Root T_floating (Round to Minus Infinity)

        case FUNC_SQRTS_D: // SQRTS/D - Square Root S_floating (Round to Plus Infinity)

        case FUNC_SQRTT_D: // SQRTT/D - Square Root T_floating (Round to Plus Infinity)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);

            double result = std::sqrt(value);



            // Apply rounding mode based on function code

            switch (instruction.function)

            {

            case FUNC_SQRTF_C:

            case FUNC_SQRTG_C:

            case FUNC_SQRTS_C:

            case FUNC_SQRTT_C:

                // Chopped rounding mode

                result = std::trunc(result);

                break;

            case FUNC_SQRTS_M:

            case FUNC_SQRTT_M:

                // Round to minus infinity

                result = std::floor(result);

                break;

            case FUNC_SQRTS_D:

            case FUNC_SQRTT_D:

                // Round to plus infinity

                result = std::ceil(result);

                break;

            default:

                // Round to nearest (default)

                result = std::round(result);

                break;

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            DEBUG_LOG(QString("ExecuteStage: SQRT F%1 (%2) -> F%3 (%4)")

                          .arg(instruction.rb)

                          .arg(value)

                          .arg(instruction.rc)

                          .arg(result));

            break;

        }



            //         case FUNC_SQRTF_S:

            //         case FUNC_SQRTG_S:

            //         case FUNC_SQRTS_S:

            //         case FUNC_SQRTF_SC:

            //         case FUNC_SQRTG_SC:

            //         case FUNC_SQRTS_UD:

            //         case FUNC_SQRTT_UD:

            //         case FUNC_SQRTT_S:

            //         case FUNC_SQRTF_SUC:

            //         case FUNC_SQRTS_SUC:

            //         case FUNC_SQRTG_SUC:

            //         case FUNC_SQRTT_SUC:

            //         case FUNC_SQRTS_SU:

            //         case FUNC_SQRTF_SU:

            //         case FUNC_SQRTG_SU:

            //         case FUNC_SQRTT_SU:

            //         case FUNC_SQRTG_SUC:

            //         case FUNC_SQRTT_SUC:

            //         case FUNC_SQRTS_SUC:

            //         case FUNC_SQRTF_SUC:

            //         case FUNC_SQRTS_SUM:

            //         case FUNC_SQRTT_SUM:

            //         case FUNC_SQRTS_SUD:

            //         case FUNC_SQRTT_SUD:

            //         case FUNC_SQRTS_SUIC:

            //         case FUNC_SQRTS_SUIC:

            //         case FUNC_SQRTT_SUI:

            //         case FUNC_SQRTS_SUI:

            //         case FUNC_SQRTS_SUID:

            //         case FUNC_SQRTT_SUID:

            //         case FUNC_SQRTS_SUIM:

            //         case FUNC_SQRTT_SUIM:

            //         case FUNC_SQRTS_SUM:

            //         case FUNC_SQRTT_SUM:

            //         case FUNC_SQRTF_UC:

            //         case FUNC_SQRTS_UC:

            //         case FUNC_SQRTG_UC:

            //         case FUNC_SQRTT_UC



        // Add these cases to the OPCODE_FLTV switch statement in executeFloatingPointOperate()

        // These should be placed after the existing SQRT cases in the FLTV section



        // ═══════════════════════════════════════════════════════════════════════════

        // COMPLETE SQRT INSTRUCTION HANDLERS FOR ALPHA CPU

        // ═══════════════════════════════════════════════════════════════════════════



        // Scaled SQRT variants (/S)

        case FUNC_SQRTF_S: // SQRTF/S - Square Root F_floating (Scaled)

        case FUNC_SQRTG_S: // SQRTG/S - Square Root G_floating (Scaled)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);

            double result = std::sqrt(value);



            // Apply scaling - this involves normalizing the result for better precision

            // Scaled operations handle denormalized numbers differently

            if (instruction.function == FUNC_SQRTF_S)

            {

                result = m_cpu->scaleVaxFResult(result);

                DEBUG_LOG("ExecuteStage: SQRTF/S (scaled)");

            }

            else

            {

                result = m_cpu->scaleVaxGResult(result);

                DEBUG_LOG("ExecuteStage: SQRTG/S (scaled)");

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



        case FUNC_SQRTS_S: // SQRTS/S - Square Root S_floating (Scaled)

        {

            float value = m_cpu->getFloatRegister32(instruction.rb);

            float result = std::sqrt(value);



            // Apply IEEE S-floating scaling

            result = m_cpu->scaleIeeeSResult(result);

            m_cpu->setFloatRegister(instruction.rc, result);



            DEBUG_LOG("ExecuteStage: SQRTS/S (scaled)");

            break;

        }



        case FUNC_SQRTT_S: // SQRTT/S - Square Root T_floating (Scaled)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);

            double result = std::sqrt(value);



            // Apply IEEE T-floating scaling

            result = m_cpu->scaleIeeeTResult(result);

            m_cpu->setFloatRegister(instruction.rc, result);



            DEBUG_LOG("ExecuteStage: SQRTT/S (scaled)");

            break;

        }



        // Scaled and Checked SQRT variants (/SC)

        case FUNC_SQRTF_SC: // SQRTF/SC - Square Root F_floating (Scaled + Checked)

        case FUNC_SQRTG_SC: // SQRTG/SC - Square Root G_floating (Scaled + Checked)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);



            // Check for invalid inputs

            if (value < 0.0)

            {

                m_cpu->triggerFloatingPointException(AlphaCPU::FP_INVALID_OPERATION);

                result = m_cpu->getFloatingPointNaN();

            }

            else

            {

                double result = std::sqrt(value);



                if (instruction.function == FUNC_SQRTF_SC)

                {

                    result = m_cpu->scaleVaxFResult(result);

                    DEBUG_LOG("ExecuteStage: SQRTF/SC (scaled + checked)");

                }

                else

                {

                    result = m_cpu->scaleVaxGResult(result);

                    DEBUG_LOG("ExecuteStage: SQRTG/SC (scaled + checked)");

                }



                m_cpu->setFloatRegister(instruction.rc, result);

            }

            break;

        }



        // Unbiased SQRT variants (/U)

        case FUNC_SQRTF_U: // SQRTF/U - Square Root F_floating (Unbiased)

        case FUNC_SQRTS_U: // SQRTS/U - Square Root S_floating (Unbiased)

        case FUNC_SQRTG_U: // SQRTG/U - Square Root G_floating (Unbiased)

        case FUNC_SQRTT_U: // SQRTT/U - Square Root T_floating (Unbiased)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);

            double result = std::sqrt(value);



            // Unbiased rounding - round to nearest with no bias toward even/odd

            result = m_cpu->applyUnbiasedRounding(result);



            switch (instruction.function)

            {

            case FUNC_SQRTF_U:

                result = m_cpu->convertToVaxF(result);

                DEBUG_LOG("ExecuteStage: SQRTF/U (unbiased)");

                break;

            case FUNC_SQRTS_U:

                result = m_cpu->convertToIeeeS(result);

                DEBUG_LOG("ExecuteStage: SQRTS/U (unbiased)");

                break;

            case FUNC_SQRTG_U:

                result = m_cpu->convertToVaxG(result);

                DEBUG_LOG("ExecuteStage: SQRTG/U (unbiased)");

                break;

            case FUNC_SQRTT_U:

                result = m_cpu->convertToIeeeT(result);

                DEBUG_LOG("ExecuteStage: SQRTT/U (unbiased)");

                break;

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



        // Unbiased with rounding mode variants (/UD, /UM)

        case FUNC_SQRTS_UD: // SQRTS/UD - Square Root S_floating (Unbiased, round +∞)

        case FUNC_SQRTT_UD: // SQRTT/UD - Square Root T_floating (Unbiased, round +∞)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);

            double result = std::sqrt(value);



            // Apply round toward +infinity (round up)

            result = std::ceil(result * 1e15) / 1e15; // High precision ceiling



            if (instruction.function == FUNC_SQRTS_UD)

            {

                result = m_cpu->convertToIeeeS(result);

                DEBUG_LOG("ExecuteStage: SQRTS/UD (unbiased, round +∞)");

            }

            else

            {

                result = m_cpu->convertToIeeeT(result);

                DEBUG_LOG("ExecuteStage: SQRTT/UD (unbiased, round +∞)");

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



        // Scaled-Unbiased SQRT variants (/SU)

        case FUNC_SQRTF_SU: // SQRTF/SU - Square Root F_floating (Scaled + Unbiased)

        case FUNC_SQRTS_SU: // SQRTS/SU - Square Root S_floating (Scaled + Unbiased)

        case FUNC_SQRTG_SU: // SQRTG/SU - Square Root G_floating (Scaled + Unbiased)

        case FUNC_SQRTT_SU: // SQRTT/SU - Square Root T_floating (Scaled + Unbiased)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);

            double result = std::sqrt(value);



            // Apply both scaling and unbiased rounding

            result = m_cpu->applyUnbiasedRounding(result);



            switch (instruction.function)

            {

            case FUNC_SQRTF_SU:

                result = m_cpu->scaleVaxFResult(result);

                DEBUG_LOG("ExecuteStage: SQRTF/SU (scaled + unbiased)");

                break;

            case FUNC_SQRTS_SU:

                result = m_cpu->scaleIeeeSResult(result);

                DEBUG_LOG("ExecuteStage: SQRTS/SU (scaled + unbiased)");

                break;

            case FUNC_SQRTG_SU:

                result = m_cpu->scaleVaxGResult(result);

                DEBUG_LOG("ExecuteStage: SQRTG/SU (scaled + unbiased)");

                break;

            case FUNC_SQRTT_SU:

                result = m_cpu->scaleIeeeTResult(result);

                DEBUG_LOG("ExecuteStage: SQRTT/SU (scaled + unbiased)");

                break;

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



        // Scaled-Unbiased-Checked SQRT variants (/SUC)

        case FUNC_SQRTF_SUC: // SQRTF/SUC - Square Root F_floating (Scaled + Unbiased + Checked)

        case FUNC_SQRTS_SUC: // SQRTS/SUC - Square Root S_floating (Scaled + Unbiased + Checked)

        case FUNC_SQRTG_SUC: // SQRTG/SUC - Square Root G_floating (Scaled + Unbiased + Checked)

        case FUNC_SQRTT_SUC: // SQRTT/SUC - Square Root T_floating (Scaled + Unbiased + Checked)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);



            // Check for invalid inputs (negative values)

            if (value < 0.0)

            {

                m_cpu->triggerFloatingPointException(AlphaCPU::FP_INVALID_OPERATION);

                result = m_cpu->getFloatingPointNaN();

                break;

            }



            double result = std::sqrt(value);



            // Apply unbiased rounding, then scaling

            result = m_cpu->applyUnbiasedRounding(result);



            switch (instruction.function)

            {

            case FUNC_SQRTF_SUC:

                result = m_cpu->scaleVaxFResult(result);

                DEBUG_LOG("ExecuteStage: SQRTF/SUC (scaled + unbiased + checked)");

                break;

            case FUNC_SQRTS_SUC:

                result = m_cpu->scaleIeeeSResult(result);

                DEBUG_LOG("ExecuteStage: SQRTS/SUC (scaled + unbiased + checked)");

                break;

            case FUNC_SQRTG_SUC:

                result = m_cpu->scaleVaxGResult(result);

                DEBUG_LOG("ExecuteStage: SQRTG/SUC (scaled + unbiased + checked)");

                break;

            case FUNC_SQRTT_SUC:

                result = m_cpu->scaleIeeeTResult(result);

                DEBUG_LOG("ExecuteStage: SQRTT/SUC (scaled + unbiased + checked)");

                break;

            }



            // Check for overflow/underflow after scaling

            if (m_cpu->checkFloatingPointExceptions())

            {

                m_cpu->triggerFloatingPointException(AlphaCPU::FP_ARITHMETIC_TRAP);

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



        // Scaled-Unbiased with rounding modes (/SUM, /SUD)

        case FUNC_SQRTS_SUM: // SQRTS/SUM - Square Root S_floating (Scaled + Unbiased, round -∞)

        case FUNC_SQRTT_SUM: // SQRTT/SUM - Square Root T_floating (Scaled + Unbiased, round -∞)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);

            double result = std::sqrt(value);



            // Apply round toward -infinity (round down)

            result = std::floor(result * 1e15) / 1e15; // High precision floor



            if (instruction.function == FUNC_SQRTS_SUM)

            {

                result = m_cpu->scaleIeeeSResult(result);

                DEBUG_LOG("ExecuteStage: SQRTS/SUM (scaled + unbiased, round -∞)");

            }

            else

            {

                result = m_cpu->scaleIeeeTResult(result);

                DEBUG_LOG("ExecuteStage: SQRTT/SUM (scaled + unbiased, round -∞)");

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



        case FUNC_SQRTS_SUD: // SQRTS/SUD - Square Root S_floating (Scaled + Unbiased, round +∞)

        case FUNC_SQRTT_SUD: // SQRTT/SUD - Square Root T_floating (Scaled + Unbiased, round +∞)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);

            double result = std::sqrt(value);



            // Apply round toward +infinity (round up)

            result = std::ceil(result * 1e15) / 1e15; // High precision ceiling



            if (instruction.function == FUNC_SQRTS_SUD)

            {

                result = m_cpu->scaleIeeeSResult(result);

                DEBUG_LOG("ExecuteStage: SQRTS/SUD (scaled + unbiased, round +∞)");

            }

            else

            {

                result = m_cpu->scaleIeeeTResult(result);

                DEBUG_LOG("ExecuteStage: SQRTT/SUD (scaled + unbiased, round +∞)");

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



        // Scaled-Unbiased-Inexact variants (/SUI, /SUIC, /SUIM, /SUID)

        case FUNC_SQRTS_SUI: // SQRTS/SUI - Square Root S_floating (Scaled + Unbiased + Inexact)

        case FUNC_SQRTT_SUI: // SQRTT/SUI - Square Root T_floating (Scaled + Unbiased + Inexact)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);

            double result = std::sqrt(value);



            // Apply unbiased rounding and check for inexact result

            double rounded = m_cpu->applyUnbiasedRounding(result);

            if (rounded != result)

            {

                m_cpu->setFloatingPointFlag(AlphaCPU::FP_INEXACT);

            }



            if (instruction.function == FUNC_SQRTS_SUI)

            {

                rounded = m_cpu->scaleIeeeSResult(rounded);

                DEBUG_LOG("ExecuteStage: SQRTS/SUI (scaled + unbiased + inexact)");

            }

            else

            {

                rounded = m_cpu->scaleIeeeTResult(rounded);

                DEBUG_LOG("ExecuteStage: SQRTT/SUI (scaled + unbiased + inexact)");

            }



            m_cpu->setFloatRegister(instruction.rc, rounded);

            break;

        }



        case FUNC_SQRTS_SUIC: // SQRTS/SUIC - Square Root S_floating (Scaled + Unbiased + Inexact + Checked)

        case FUNC_SQRTT_SUIC: // SQRTT/SUIC - Square Root T_floating (Scaled + Unbiased + Inexact + Checked)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);



            // Check for invalid inputs

            if (value < 0.0)

            {

                m_cpu->triggerFloatingPointException(AlphaCPU::FP_INVALID_OPERATION);

                result = m_cpu->getFloatingPointNaN();

                break;

            }



            double result = std::sqrt(value);



            // Apply unbiased rounding and check for inexact result

            double rounded = m_cpu->applyUnbiasedRounding(result);

            if (rounded != result)

            {

                m_cpu->setFloatingPointFlag(AlphaCPU::FP_INEXACT);

            }



            if (instruction.function == FUNC_SQRTS_SUIC)

            {

                rounded = m_cpu->scaleIeeeSResult(rounded);

                DEBUG_LOG("ExecuteStage: SQRTS/SUIC (scaled + unbiased + inexact + checked)");

            }

            else

            {

                rounded = m_cpu->scaleIeeeTResult(rounded);

                DEBUG_LOG("ExecuteStage: SQRTT/SUIC (scaled + unbiased + inexact + checked)");

            }



            m_cpu->setFloatRegister(instruction.rc, rounded);

            break;

        }



        case FUNC_SQRTS_SUIM: // SQRTS/SUIM - Square Root S_floating (Scaled + Unbiased + Inexact, round -∞)

        case FUNC_SQRTT_SUIM: // SQRTT/SUIM - Square Root T_floating (Scaled + Unbiased + Inexact, round -∞)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);

            double result = std::sqrt(value);



            // Apply round toward -infinity and check for inexact

            double rounded = std::floor(result * 1e15) / 1e15;

            if (rounded != result)

            {

                m_cpu->setFloatingPointFlag(AlphaCPU::FP_INEXACT);

            }



            if (instruction.function == FUNC_SQRTS_SUIM)

            {

                rounded = m_cpu->scaleIeeeSResult(rounded);

                DEBUG_LOG("ExecuteStage: SQRTS/SUIM (scaled + unbiased + inexact, round -∞)");

            }

            else

            {

                rounded = m_cpu->scaleIeeeTResult(rounded);

                DEBUG_LOG("ExecuteStage: SQRTT/SUIM (scaled + unbiased + inexact, round -∞)");

            }



            m_cpu->setFloatRegister(instruction.rc, rounded);

            break;

        }



        case FUNC_SQRTS_SUID: // SQRTS/SUID - Square Root S_floating (Scaled + Unbiased + Inexact, round +∞)

        case FUNC_SQRTT_SUID: // SQRTT/SUID - Square Root T_floating (Scaled + Unbiased + Inexact, round +∞)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);

            double result = std::sqrt(value);



            // Apply round toward +infinity and check for inexact

            double rounded = std::ceil(result * 1e15) / 1e15;

            if (rounded != result)

            {

                m_cpu->setFloatingPointFlag(AlphaCPU::FP_INEXACT);

            }



            if (instruction.function == FUNC_SQRTS_SUID)

            {

                rounded = m_cpu->scaleIeeeSResult(rounded);

                DEBUG_LOG("ExecuteStage: SQRTS/SUID (scaled + unbiased + inexact, round +∞)");

            }

            else

            {

                rounded = m_cpu->scaleIeeeTResult(rounded);

                DEBUG_LOG("ExecuteStage: SQRTT/SUID (scaled + unbiased + inexact, round +∞)");

            }



            m_cpu->setFloatRegister(instruction.rc, rounded);

            break;

        }



        // Unbiased + Checked variants (/UC)

        case FUNC_SQRTF_UC: // SQRTF/UC - Square Root F_floating (Unbiased + Checked)

        case FUNC_SQRTS_UC: // SQRTS/UC - Square Root S_floating (Unbiased + Checked)

        case FUNC_SQRTG_UC: // SQRTG/UC - Square Root G_floating (Unbiased + Checked)

        case FUNC_SQRTT_UC: // SQRTT/UC - Square Root T_floating (Unbiased + Checked)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);



            // Check for invalid inputs

            if (value < 0.0)

            {

                m_cpu->triggerFloatingPointException(AlphaCPU::FP_INVALID_OPERATION);

                result = m_cpu->getFloatingPointNaN();

                break;

            }



            double result = std::sqrt(value);



            // Apply unbiased rounding

            result = m_cpu->applyUnbiasedRounding(result);



            switch (instruction.function)

            {

            case FUNC_SQRTF_UC:

                result = m_cpu->convertToVaxF(result);

                DEBUG_LOG("ExecuteStage: SQRTF/UC (unbiased + checked)");

                break;

            case FUNC_SQRTS_UC:

                result = m_cpu->convertToIeeeS(result);

                DEBUG_LOG("ExecuteStage: SQRTS/UC (unbiased + checked)");

                break;

            case FUNC_SQRTG_UC:

                result = m_cpu->convertToVaxG(result);

                DEBUG_LOG("ExecuteStage: SQRTG/UC (unbiased + checked)");

                break;

            case FUNC_SQRTT_UC:

                result = m_cpu->convertToIeeeT(result);

                DEBUG_LOG("ExecuteStage: SQRTT/UC (unbiased + checked)");

                break;

            }



            // Check for exceptions after conversion

            if (m_cpu->checkFloatingPointExceptions())

            {

                m_cpu->triggerFloatingPointException(AlphaCPU::FP_ARITHMETIC_TRAP);

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



            // ═══════════════════════════════════════════════════════════════════════════

            // END OF SQRT INSTRUCTION HANDLERS

            // ═══════════════════════════════════════════════════════════════════════════

            // ═══════════════════════════════════════════════════════════════════════════

        // SQRT UNBIASED HANDLERS (/U suffix - NOT unnormalized, but unbiased rounding)

        // ═══════════════════════════════════════════════════════════════════════════



        // Unbiased + Chopped variants (/UC)

        case FUNC_SQRTF_UC: // SQRTF/UC - Square Root F_floating (Unbiased + Chopped)

        case FUNC_SQRTG_UC: // SQRTG/UC - Square Root G_floating (Unbiased + Chopped)

        case FUNC_SQRTS_UC: // SQRTS/UC - Square Root S_floating (Unbiased + Chopped)

        case FUNC_SQRTT_UC: // SQRTT/UC - Square Root T_floating (Unbiased + Chopped)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);



            // Check for negative input (invalid for square root)

            if (value < 0.0)

            {

                m_cpu->triggerFloatingPointException(AlphaCPU::FP_INVALID_OPERATION);

                result = m_cpu->getFloatingPointQuietNaN();

                m_cpu->setFloatRegister(instruction.rc, result);

                break;

            }



            double result = std::sqrt(value);



            // Apply chopped (truncated) rounding - round toward zero

            result = std::trunc(result);



            // Apply format-specific conversion

            switch (instruction.function)

            {

            case FUNC_SQRTF_UC:

                result = m_cpu->convertToVaxFWithUnbiasedRounding(result, AlphaCPU::ROUND_CHOPPED);

                DEBUG_LOG("ExecuteStage: SQRTF/UC (unbiased + chopped)");

                break;

            case FUNC_SQRTG_UC:

                result = m_cpu->convertToVaxGWithUnbiasedRounding(result, AlphaCPU::ROUND_CHOPPED);

                DEBUG_LOG("ExecuteStage: SQRTG/UC (unbiased + chopped)");

                break;

            case FUNC_SQRTS_UC:

                result = m_cpu->convertToIeeeSWithUnbiasedRounding(result, AlphaCPU::ROUND_CHOPPED);

                DEBUG_LOG("ExecuteStage: SQRTS/UC (unbiased + chopped)");

                break;

            case FUNC_SQRTT_UC:

                result = m_cpu->convertToIeeeTWithUnbiasedRounding(result, AlphaCPU::ROUND_CHOPPED);

                DEBUG_LOG("ExecuteStage: SQRTT/UC (unbiased + chopped)");

                break;

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



        // Unbiased + Round to Minus Infinity (/UM)

        case FUNC_SQRTS_UM: // SQRTS/UM - Square Root S_floating (Unbiased + Round -∞)

        case FUNC_SQRTT_UM: // SQRTT/UM - Square Root T_floating (Unbiased + Round -∞)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);



            if (value < 0.0)

            {

                m_cpu->triggerFloatingPointException(AlphaCPU::FP_INVALID_OPERATION);

                result = m_cpu->getFloatingPointQuietNaN();

                m_cpu->setFloatRegister(instruction.rc, result);

                break;

            }



            double result = std::sqrt(value);



            // Apply round toward minus infinity (floor)

            result = std::floor(result);



            if (instruction.function == FUNC_SQRTS_UM)

            {

                result = m_cpu->convertToIeeeSWithUnbiasedRounding(result, AlphaCPU::ROUND_MINUS_INFINITY);

                DEBUG_LOG("ExecuteStage: SQRTS/UM (unbiased + round -∞)");

            }

            else

            {

                result = m_cpu->convertToIeeeTWithUnbiasedRounding(result, AlphaCPU::ROUND_MINUS_INFINITY);

                DEBUG_LOG("ExecuteStage: SQRTT/UM (unbiased + round -∞)");

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



        // Basic Unbiased (/U)

        case FUNC_SQRTS_U: // SQRTS/U - Square Root S_floating (Unbiased)

        case FUNC_SQRTT_U: // SQRTT/U - Square Root T_floating (Unbiased)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);



            if (value < 0.0)

            {

                m_cpu->triggerFloatingPointException(AlphaCPU::FP_INVALID_OPERATION);

                result = m_cpu->getFloatingPointQuietNaN();

                m_cpu->setFloatRegister(instruction.rc, result);

                break;

            }



            double result = std::sqrt(value);



            // Apply unbiased rounding (round to nearest, ties away from zero)

            result = m_cpu->applyUnbiasedRounding(result);



            if (instruction.function == FUNC_SQRTS_U)

            {

                result = m_cpu->convertToIeeeSWithUnbiasedRounding(result, AlphaCPU::ROUND_NEAREST);

                DEBUG_LOG("ExecuteStage: SQRTS/U (unbiased)");

            }

            else

            {

                result = m_cpu->convertToIeeeTWithUnbiasedRounding(result, AlphaCPU::ROUND_NEAREST);

                DEBUG_LOG("ExecuteStage: SQRTT/U (unbiased)");

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



        // Unbiased + Round to Plus Infinity (/UD)

        case FUNC_SQRTS_UD: // SQRTS/UD - Square Root S_floating (Unbiased + Round +∞)

        case FUNC_SQRTT_UD: // SQRTT/UD - Square Root T_floating (Unbiased + Round +∞)

        {

            double value = m_cpu->getFloatRegister(instruction.rb);



            if (value < 0.0)

            {

                m_cpu->triggerFloatingPointException(AlphaCPU::FP_INVALID_OPERATION);

                result = m_cpu->getFloatingPointQuietNaN();

                m_cpu->setFloatRegister(instruction.rc, result);

                break;

            }



            double result = std::sqrt(value);



            // Apply round toward plus infinity (ceil)

            result = std::ceil(result);



            if (instruction.function == FUNC_SQRTS_UD)

            {

                result = m_cpu->convertToIeeeSWithUnbiasedRounding(result, AlphaCPU::ROUND_PLUS_INFINITY);

                DEBUG_LOG("ExecuteStage: SQRTS/UD (unbiased + round +∞)");

            }

            else

            {

                result = m_cpu->convertToIeeeTWithUnbiasedRounding(result, AlphaCPU::ROUND_PLUS_INFINITY);

                DEBUG_LOG("ExecuteStage: SQRTT/UD (unbiased + round +∞)");

            }



            m_cpu->setFloatRegister(instruction.rc, result);

            break;

        }



        /*  VAX floating-point conversions */

        case FUNC_CVTQF_C:  // CVTQF/C - Convert Quadword to F_floating (Chopped)

        case FUNC_CVTQF:    // CVTQF - Convert Quadword to F_floating

        case FUNC_CVTQF_UC: // CVTQF/UC - Convert Quadword to F_floating (Unbiased/Scaled Chopped)

            result = convertQuadToF(instruction, raValue);

            DEBUG_LOG(QString("ExecuteStage: CVTQF variant 0x%1").arg(instruction.function, 3, 16, QChar('0')));

            break;



        case FUNC_CVTQG_C:  // CVTQG/C - Convert Quadword to G_floating (Chopped)

        case FUNC_CVTQG:    // CVTQG - Convert Quadword to G_floating

        case FUNC_CVTQG_UC: // CVTQG/UC - Convert Quadword to G_floating (Unbiased/Scaled Chopped)

            result = convertQuadToG(instruction, raValue);

            DEBUG_LOG(QString("ExecuteStage: CVTQG variant 0x%1").arg(instruction.function, 3, 16, QChar('0')));

            break;



        case FUNC_CVTGF_C:  // CVTGF/C - Convert G_floating to F_floating (Chopped)

        case FUNC_CVTGF:    // CVTGF - Convert G_floating to F_floating

        case FUNC_CVTGF_UC: // CVTGF/UC - Convert G_floating to F_floating (Unbiased/Scaled Chopped)

            result = convertGToF(instruction, faValue); // Note: use faValue for G-to-F conversion

            DEBUG_LOG(QString("ExecuteStage: CVTGF variant 0x%1").arg(instruction.function, 3, 16, QChar('0')));

            break;



        default:

            DEBUG_LOG(

                QString("ExecuteStage: Unimplemented FLTV function 0x%1").arg(instruction.function, 2, 16, QChar('0')));

            m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

            return;

        }

        break;

    }



    case OPCODE_FLTI: // FLTI - IEEE Floating-Point

    {

        switch (instruction.function)

        {

        case FUNC_ADDS_C: // ADDS/C - Add S_floating (Chopped)

        case FUNC_ADDS_M: // ADDS/M - Add S_floating (Round to Minus Infinity)

        case FUNC_ADDS:   // ADDS - Add S_floating (Round to Nearest)

        case FUNC_ADDS_D: // ADDS/D - Add S_floating (Round to Plus Infinity)

            result = m_cpu->addSFormat(faValue, fbValue, instruction.function >> 6);

            DEBUG_LOG("ExecuteStage: ADDS");

            break;



        case FUNC_SUBS_C: // SUBS/C - Subtract S_floating (Chopped)

        case FUNC_SUBS_M: // SUBS/M - Subtract S_floating (Round to Minus Infinity)

        case FUNC_SUBS:   // SUBS - Subtract S_floating (Round to Nearest)

        case FUNC_SUBS_D: // SUBS/D - Subtract S_floating (Round to Plus Infinity)

            result = m_cpu->subSFormat(faValue, fbValue, instruction.function >> 6);

            DEBUG_LOG("ExecuteStage: SUBS");

            break;



        case FUNC_MULS_C: // MULS/C - Multiply S_floating (Chopped)

        case FUNC_MULS_M: // MULS/M - Multiply S_floating (Round to Minus Infinity)

        case FUNC_MULS:   // MULS - Multiply S_floating (Round to Nearest)

        case FUNC_MULS_D: // MULS/D - Multiply S_floating (Round to Plus Infinity)

            result = m_cpu->mulSFormat(faValue, fbValue, instruction.function >> 6);

            DEBUG_LOG("ExecuteStage: MULS");

            break;



        case FUNC_DIVS_C: // DIVS/C - Divide S_floating (Chopped)

        case FUNC_DIVS_M: // DIVS/M - Divide S_floating (Round to Minus Infinity)

        case FUNC_DIVS:   // DIVS - Divide S_floating (Round to Nearest)

        case FUNC_DIVS_D: // DIVS/D - Divide S_floating (Round to Plus Infinity)

            result = m_cpu->divSFormat(faValue, fbValue, instruction.function >> 6);

            DEBUG_LOG("ExecuteStage: DIVS");

            break;



        case FUNC_ADDT_C: // ADDT/C - Add T_floating (Chopped)

        case FUNC_ADDT_M: // ADDT/M - Add T_floating (Round to Minus Infinity)

        case FUNC_ADDT:   // ADDT - Add T_floating (Round to Nearest)

        case FUNC_ADDT_D: // ADDT/D - Add T_floating (Round to Plus Infinity)

            result = m_cpu->addTFormat(faValue, fbValue, instruction.function >> 6);

            DEBUG_LOG("ExecuteStage: ADDT");

            break;



        case FUNC_SUBT_C: // SUBT/C - Subtract T_floating (Chopped)

        case FUNC_SUBT_M: // SUBT/M - Subtract T_floating (Round to Minus Infinity)

        case FUNC_SUBT:   // SUBT - Subtract T_floating (Round to Nearest)

        case FUNC_SUBT_D: // SUBT/D - Subtract T_floating (Round to Plus Infinity)

            result = m_cpu->subTFormat(faValue, fbValue, instruction.function >> 6);

            DEBUG_LOG("ExecuteStage: SUBT");

            break;



        case FUNC_MULT_C: // MULT/C - Multiply T_floating (Chopped)

        case FUNC_MULT_M: // MULT/M - Multiply T_floating (Round to Minus Infinity)

        case FUNC_MULT:   // MULT - Multiply T_floating (Round to Nearest)

        case FUNC_MULT_D: // MULT/D - Multiply T_floating (Round to Plus Infinity)

            result = m_cpu->mulTFormat(faValue, fbValue, instruction.function >> 6);

            DEBUG_LOG("ExecuteStage: MULT");

            break;



        case FUNC_DIVT_C: // DIVT/C - Divide T_floating (Chopped)

        case FUNC_DIVT_M: // DIVT/M - Divide T_floating (Round to Minus Infinity)

        case FUNC_DIVT:   // DIVT - Divide T_floating (Round to Nearest)

        case FUNC_DIVT_D: // DIVT/D - Divide T_floating (Round to Plus Infinity)

            result = m_cpu->divTFormat(faValue, fbValue, instruction.function >> 6);

            DEBUG_LOG("ExecuteStage: DIVT");

            break;



        case FUNC_CMPTUN: // CMPTUN - Compare T_floating Unordered

            result = m_cpu->compareTFormat(faValue, fbValue, AlphaCPU::FP_UNORDERED);

            DEBUG_LOG("ExecuteStage: CMPTUN");

            break;



        case FUNC_CMPTEQ: // CMPTEQ - Compare T_floating Equal

            result = m_cpu->compareTFormat(faValue, fbValue, AlphaCPU::FP_EQUAL);

            DEBUG_LOG("ExecuteStage: CMPTEQ");

            break;



        case FUNC_CMPTLT: // CMPTLT - Compare T_floating Less Than

            result = m_cpu->compareTFormat(faValue, fbValue, AlphaCPU::FP_LESS);

            DEBUG_LOG("ExecuteStage: CMPTLT");

            break;



        case FUNC_CMPTLE: // CMPTLE - Compare T_floating Less Than or Equal

            result = m_cpu->compareTFormat(faValue, fbValue, AlphaCPU::FP_LESS_EQUAL);

            DEBUG_LOG("ExecuteStage: CMPTLE");

            break;



        default:

            DEBUG_LOG(

                QString("ExecuteStage: Unimplemented FLTI function 0x%1").arg(instruction.function, 2, 16, QChar('0')));

            m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

            return;

        }

        break;

    }



    case OPCODE_FLTL: // FLTL - Floating-Point Conversion and Move

    {

        switch (instruction.function)

        {

        case FUNC_CVTTQ_C:   // CVTTQ/C - (CVTTQ/C (chopped)) Convert T_floating to Quadword (Chopped)

        case FUNC_CVTTQ_VC:  // CVTTQ/V/C - (CVTTQ/V/C (chop + trap)) Convert T_floating to Quadword with overflow trap

                             // (Chopped)

        case FUNC_CVTTQ_SC:  // CVTTQ/S/C - (CVTTQ/S/C (chop + software)) Convert T_floating to Quadword with software

                             // completion (Chopped)

        case FUNC_CVTTQ_SVC: // CVTTQ/S/V/C - (CVTTQ/S/V/C (chop + S + V)) Convert T_floating to Quadword, both traps

                             // (Chopped)

        case FUNC_CVTTQ:     // CVTTQ - (CVTTQ (round-to-nearest)) Convert T_floating to Quadword (Round to Nearest)

        case FUNC_CVTTQ_V:   // CVTTQ/V - (CVTTQ/V (nearest + trap)) Convert T_floating to Quadword with overflow trap

        case FUNC_CVTTQ_S:   // CVTTQ/S - (CVTTQ/S (nearest + software)) Convert T_floating to Quadword with software

                             // completion

        case FUNC_CVTTQ_SV:  // CVTTQ/S/V - (CVTTQ/S/V (nearest + S + V)) Convert T_floating to Quadword, both traps

            result = m_cpu->convertTToQuad(faValue, instruction.function);

            DEBUG_LOG("ExecuteStage: CVTTQ");

            break;



        case FUNC_CVTQF_C: // CVTQF/C - Convert Quadword to F_floating (Chopped)

        case FUNC_CVTQF:   // CVTQF - Convert Quadword to F_floating (Round to Nearest)

            result = m_cpu->convertQuadToF(faValue, instruction.function >> 6);

            DEBUG_LOG("ExecuteStage: CVTQF");

            break;



        case FUNC_CVTQS_C: // CVTQS/C - Convert Quadword to S_floating (Chopped)

        case FUNC_CVTQS_M: // CVTQS/M - Convert Quadword to S_floating (Round to Minus Infinity)

        case FUNC_CVTQS:   // CVTQS - Convert Quadword to S_floating (Round to Nearest)

        case FUNC_CVTQS_D: // CVTQS/D - Convert Quadword to S_floating (Round to Plus Infinity)

            result = m_cpu->convertQuadToS(faValue, instruction.function >> 6);

            DEBUG_LOG("ExecuteStage: CVTQS");

            break;



        case FUNC_CVTQT_C: // CVTQT/C - Convert Quadword to T_floating (Chopped)

        case FUNC_CVTQT_M: // CVTQT/M - Convert Quadword to T_floating (Round to Minus Infinity)

        case FUNC_CVTQT:   // CVTQT - Convert Quadword to T_floating (Round to Nearest)

        case FUNC_CVTQT_D: // CVTQT/D - Convert Quadword to T_floating (Round to Plus Infinity)

            result = m_cpu->convertQuadToT(faValue, instruction.function >> 6);

            DEBUG_LOG("ExecuteStage: CVTQT");

            break;



        case 0x120:        // FCMOV - Floating Conditional Move

        case FUNC_FCMOVNE: // FCMOVNE - Floating Conditional Move if Not Equal

        case FUNC_FCMOVLT: // FCMOVLT - Floating Conditional Move if Less Than

        case FUNC_FCMOVGE: // FCMOVGE - Floating Conditional Move if Greater Equal

        case FUNC_FCMOVLE: // FCMOVLE - Floating Conditional Move if Less Equal

        case FUNC_FCMOVGT: // FCMOVGT - Floating Conditional Move if Greater Than

            result = m_cpu->floatConditionalMove(faValue, fbValue, (instruction.function & 0x7),

                                                 m_cpu->getFloatRegister64(instruction.rc));

            DEBUG_LOG(QString("ExecuteStage: FCMOV variant 0x%1").arg(instruction.function & 0x7, 1, 16));

            break;



        case FUNC_CPYS: // CPYS - Copy Sign

            result = m_cpu->copySign(faValue, fbValue);

            DEBUG_LOG("ExecuteStage: CPYS");

            break;



        case FUNC_CPYSN: // CPYSN - Copy Sign Negate

            result = m_cpu->copySignNegate(faValue, fbValue);

            DEBUG_LOG("ExecuteStage: CPYSN");

            break;



        case FUNC_CPYSE: // CPYSE - Copy Sign and Exponent

            result = m_cpu->copySignExponent(faValue, fbValue);

            DEBUG_LOG("ExecuteStage: CPYSE");

            break;



        case FUNC_MT_FPCR: // MT_FPCR - Move to Floating-Point Control Register

            m_cpu->setFPCR(faValue);

            result = 0; // No destination register

            DEBUG_LOG("ExecuteStage: MT_FPCR");

            break;



        case FUNC_MF_FPCR: // MF_FPCR - Move from Floating-Point Control Register

            result = m_cpu->getFPCR();

            DEBUG_LOG("ExecuteStage: MF_FPCR");

            break;



        default:

            DEBUG_LOG(

                QString("ExecuteStage: Unimplemented FLTL function 0x%1").arg(instruction.function, 3, 16, QChar('0')));

            m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

            return;

        }

        break;

    }



    default:

        DEBUG_LOG(

            QString("ExecuteStage: Unknown floating-point opcode 0x%1").arg(instruction.opcode, 2, 16, QChar('0')));

        m_cpu->triggerException(AlphaCPU::ILLEGAL_INSTRUCTION, m_cpu->getPC());

        return;

    }



    // Store result in floating-point register

    if (instruction.rc != 31)

    {

        m_cpu->setFloatRegister(instruction.rc, result);

    }



    // Check for floating-point exceptions

    if (m_cpu->checkFloatingPointExceptions())

    {

        m_cpu->triggerException(AlphaCPU::FLOATING_POINT_EXCEPTION, m_cpu->getPC());

    }

}


