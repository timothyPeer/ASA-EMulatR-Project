<!DOCTYPE html>
<html>
<head>
   <title>Case Example Architecture Aware</title>
   <meta name="viewport" content="width=device-width, initial-scale=1">
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />   
   <meta http-equiv="X-UA-Compatible" content="IE=edge" />
   <meta name="generator" content="Help &amp; Manual" />
   <meta name="keywords" content="" />
   <meta name="description" content="regarding Alpha System Architecture platform development, I wish to design an emulation application which is capable of booting to the following support Alpha Architectures:..." />
   <link type="text/css" href="default.css" rel="stylesheet" />
   <link type="text/css" href="custom.css" rel="stylesheet" />

   <style TYPE="text/css" media="screen"> 
      html, body { margin:0; 
        padding:0; 
        background: #ffffff; 
      } 
      div#printheader { display: none; }
      #idheader { 
        width:100%; 
        min-height: 60px; 
        padding: 0; 
        margin: 0;
        position: fixed;
        top: 0;
        background: #2C5D88;
        z-index: 2;
      } 
      /* The "min-height" for "#idheader table" ensures that the (blue) header of the topic
         has at least the same height as the header of the navigation panel left of it */
      #idheader table { min-height: 59px;}             
      #idheader h1 span { color: #FFF }     
      #idnav {
        text-align: right;
        width: 126px;
        vertical-align: middle;        
      } 
      #idnav a { text-decoration: none }
      #idnav span {
        display: inline-block;
        width: 24px;
        height: 24px;
        margin-left: 4px;
        background:url('hm_webhelp_buttons_grey.png') top left no-repeat;
      } 
      #idnav a span {
        background-image:url('hm_webhelp_buttons_white.png');
      } 
      #idnav a span:hover {
        background-image:url('hm_webhelp_buttons_orange.png');
      } 
      #idnav span.hmbtnprev { background-position: 0 -32px }
      #idnav span.hmbtnnext { background-position: -24px -32px }
      #idnav span.hmbtntop  { background-position: -48px -32px }
      #idnav span.hmbtntoggle  { width: 20px; background-position: -70px -32px }
      #idnav span.hmbtnprint  { background-position: -88px -32px }

      #callout-table, #overview-table {display:block; position:relative; top:0; left:0;}
      #callout-icon {display:block; position:absolute; top:-11px; left:-11px;}
      #callout-icon-flag {display:block; position:absolute; top:-11px; left:-8px;}
      #callout-table a {text-decoration: none; color: blue;}
      #callout-table a:visited {text-decoration: none; color: blue;}
      #overview-table a {text-decoration: none; color: black;}
      #overview-table a:visited {text-decoration: none; color: black;}
      #callout-table a:hover, #overview-table a:hover {text-decoration: underline;}       
      p.help-url { margin: 20px 0 5px 0; text-align: center; }
	  p.help-url a:link { font-size: 50%; text-decoration: none; color: black; }
	  p.help-url a:visited { color: black; }
	  p.help-url a:hover { font-size: 95%; text-decoration: underline; }
      #switchtoggles { text-align: right; padding: 0 2px 0 0; font-size: 90%; } 
      .sync-toc { color: #FFF; font-size: 8pt; font-weight: bold; display: none; }
      .sync-toc a { color: #FFF; text-decoration: none; font-weight: bold;}
      .sync-toc a:visited { color: #FFF; }
      .sync-toc a:hover { text-decoration: underline; }
	  a#printbuttonlink { cursor: pointer; }
      a.hmanchor { display: inline-block; margin-top: -4em; padding-top: 4em; }  
   </style>
   <style TYPE="text/css" media="print">
      div#idheader, img.dropdown-toggle-icon, p.help-url { display:none } 
   </style>
   
   <script type="text/javascript" src="jquery.js"></script>
   <script type="text/javascript" src="helpman_settings.js"></script>
   <script type="text/javascript" src="helpman_topicinit.js"></script>

   <script type="text/javascript">
     HMSyncTOC("index.html", "case-example-architecture-awar.html");
   </script>
   <script type="text/javascript" src="highlight.js"></script>
   <script type="text/javascript">
     $(document).ready(function(){highlight();});
   </script>
</head>
<body>


<div id="printheader"><h1 class="p_Heading1" style="page-break-after: avoid;"><span class="f_Heading1">Case Example Architecture Aware</span></h1>
</div>
<div id="idheader">
<div id="idheaderbg">
<table style="width:100%;border:none;margin:0px;" cellspacing="0" cellpadding="0"> 
  <tr>
    <td class="topichead" style="text-align:left; vertical-align:middle">
      <p class="sync-toc">&lt;&lt; <a rel="nofollow" href="index.html?case-example-architecture-awar.html" target="_top">Click to Display Table of Contents</a> &gt;&gt;</p>
      <p class="crumbs"><b>Navigation:</b>&nbsp;
      &raquo;No topics above this level&laquo;
      </p>
   
      <h1 class="p_Heading1" style="page-break-after: avoid;"><span class="f_Heading1">Case Example Architecture Aware</span></h1>

    </td>
    <td class="topichead" id="idnav">
      
      <span class="hmbtnprev"></span>
      <a href="introduction.html" title="Parent Chapter"><span class="hmbtntop"></span></a>
      <span class="hmbtnnext"></span>
      
    </td>
  </tr>  
</table>
</div>
</div>  

<div id="idcontent"><div id="innerdiv">
<!-- Ask Internet Explorer 6.users to update their obsolete and dangerous browser --> 
<!--[if lt IE 7]><div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;'><a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://storage.ie6countdown.com/assets/100/images/banners/warning_bar_0000_us.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today." /></a></div><![endif]-->

<!--ZOOMRESTART-->
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">regarding Alpha System Architecture platform development, I wish to design an emulation application which is capable of booting to the following support Alpha Architectures: VAX, Tru64/Ultrix, Unix, OSF/1, and Alpha. &nbsp;The question is presented as there are distinct architecture differences between these architectures, e.g. 32-bit vs 64-bit being the most notable difference. &nbsp; So, in the construction of the software, I would like to code the system using a unified pattern approach and depending on platform, switch executed code to the architecture of interest. An example, the FCPR on Alpha is coded for 64-bit, on VAX it is coded as 32-bit. &nbsp; &nbsp;This question is further complicated as I wish to toggle to the desired platform architecture at boot time . &nbsp;What are your thoughts... Please no canvas, just a discussion on available options.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">This is a fascinating and complex emulation challenge. You're essentially building a multi-architecture emulator with runtime switching capabilities - similar to what QEMU does but with a focus on DEC/Compaq Alpha family systems. Let me break down the key architectural considerations and potential approaches:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Architecture Differences to Consider</p>
<p class="p_Normal">VAX (32-bit)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">CISC architecture with variable-length instructions</p>
<p class="p_Normal">32-bit addressing and data paths</p>
<p class="p_Normal">Unique VAX floating-point formats</p>
<p class="p_Normal">Memory management via page tables with different structure</p>
<p class="p_Normal">Alpha (64-bit)</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">RISC architecture with fixed 32-bit instruction length</p>
<p class="p_Normal">64-bit addressing and registers</p>
<p class="p_Normal">IEEE 754 floating-point compliance</p>
<p class="p_Normal">Different memory management and cache coherency models</p>
<p class="p_Normal">Operating System Variations</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">VAX: VMS, Ultrix (4.3BSD-based)</p>
<p class="p_Normal">Alpha: Tru64 UNIX, OSF/1, OpenVMS Alpha, various Linux distributions</p>
<p class="p_Normal">Different system call interfaces, executable formats, and runtime environments</p>
<p class="p_Normal">Unified Pattern Approaches</p>
<p class="p_Normal">1. Abstract Execution Engine Pattern</p>
<p class="p_Normal">Create a common interface layer with architecture-specific implementations:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">ExecutionEngine (interface)</p>
<p class="p_Normal">├── VAXEngine (32-bit implementation)</p>
<p class="p_Normal">├── AlphaEngine (64-bit implementation)</p>
<p class="p_Normal">└── CommonServices (shared utilities)</p>
<p class="p_Normal">Key components would include:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Abstract CPU interface (registers, instruction decode, execution)</p>
<p class="p_Normal">Memory management abstraction</p>
<p class="p_Normal">Floating-point unit abstraction</p>
<p class="p_Normal">I/O system abstraction</p>
<p class="p_Normal">2. Template-Based Architecture</p>
<p class="p_Normal">Use C++ templates or similar generic programming to create compile-time polymorphism:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Template parameters for word size (32/64-bit)</p>
<p class="p_Normal">Architecture-specific specializations</p>
<p class="p_Normal">Conditional compilation based on target architecture</p>
<p class="p_Normal">3. Interpreter with Architecture Context</p>
<p class="p_Normal">Single interpreter core that switches behavior based on architecture context:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Runtime architecture state machine</p>
<p class="p_Normal">Instruction set lookup tables</p>
<p class="p_Normal">Dynamic dispatch based on current architecture mode</p>
<p class="p_Normal">Runtime Architecture Switching Strategies</p>
<p class="p_Normal">Boot-Time Selection</p>
<p class="p_Normal">Configuration file or command-line parameter</p>
<p class="p_Normal">Initialize appropriate architecture engine</p>
<p class="p_Normal">Load corresponding ROM/firmware images</p>
<p class="p_Normal">Set up architecture-specific memory maps</p>
<p class="p_Normal">Hot-Switching Considerations</p>
<p class="p_Normal">If you want to switch architectures after boot (more complex):</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Save complete machine state</p>
<p class="p_Normal">Reinitialize execution engine</p>
<p class="p_Normal">Handle cross-architecture data migration</p>
<p class="p_Normal">Manage different endianness if applicable</p>
<p class="p_Normal">Implementation Recommendations</p>
<p class="p_Normal">Modular Component Design</p>
<p class="p_Normal">CPU Core: Separate instruction decode, execution units</p>
<p class="p_Normal">Memory Subsystem: Abstract memory management with arch-specific page table handling</p>
<p class="p_Normal">FPU: Your FCPR example is perfect - abstract FPU interface with 32/64-bit implementations</p>
<p class="p_Normal">I/O Controllers: Common peripheral interfaces (SCSI, Ethernet, etc.)</p>
<p class="p_Normal">Firmware/BIOS: Architecture-specific boot loaders</p>
<p class="p_Normal">Data Structure Strategy</p>
<p class="p_Normal">Use unions or variant types for registers that can be 32 or 64-bit</p>
<p class="p_Normal">Abstract pointer types that adapt to architecture word size</p>
<p class="p_Normal">Architecture-aware structure packing and alignment</p>
<p class="p_Normal">Configuration Management</p>
<p class="p_Normal">Consider a hierarchical configuration system:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Platform Configuration</p>
<p class="p_Normal">├── Architecture (VAX/Alpha)</p>
<p class="p_Normal">├── CPU Model (specific variants)</p>
<p class="p_Normal">├── Memory Layout</p>
<p class="p_Normal">├── I/O Configuration</p>
<p class="p_Normal">└── OS-Specific Settings</p>
<p class="p_Normal">Technical Challenges to Address</p>
<p class="p_Normal">Instruction Set Differences: CISC vs RISC instruction handling</p>
<p class="p_Normal">Floating-Point: VAX F/D/G formats vs IEEE 754</p>
<p class="p_Normal">Memory Models: Different virtual memory implementations</p>
<p class="p_Normal">Endianness: Ensure consistent handling across architectures</p>
<p class="p_Normal">Performance: Minimize overhead of abstraction layers</p>
<p class="p_Normal">Suggested Starting Architecture</p>
<p class="p_Normal">I'd recommend starting with a plugin-based architecture where each target system is a loadable module:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Core emulation framework with common services</p>
<p class="p_Normal">Architecture-specific plugins (VAX, Alpha)</p>
<p class="p_Normal">OS-specific personality layers</p>
<p class="p_Normal">Hardware component abstractions</p>
<p class="p_Normal">Boot-time configuration system</p>
<p class="p_Normal">This approach gives you flexibility to add new architectures later while maintaining clean separation of concerns. You could even support multiple architectures simultaneously in different virtual machines.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">What specific aspect would you like to dive deeper into? The instruction execution engine, memory management abstraction, or the plugin architecture design?</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Plugin is an interesting option. &nbsp;It was not considered; with the model, how would this work? &nbsp;The reason I ask, the VAX arithmetic instructions as outlined in ASA Sites and Witek do not differentiate the instruction-set except to note the register layout, use of operands with the instruction, trapping and exception handling. &nbsp;So, would I create a VS project that consists of only Instructiongrains?</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">You're absolutely right to question this - the plugin approach might be overengineering for your specific case. Let me reconsider based on your VAX instruction set observation from Sites and Witek.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Rethinking the Architecture</p>
<p class="p_Normal">Since VAX instructions don't fundamentally differ in their logical operation but rather in their data representation and operand handling, a plugin-per-architecture might create unnecessary complexity. You're dealing with the same conceptual instructions (ADD, MUL, MOV, etc.) but with different:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Register widths (32 vs 64-bit)</p>
<p class="p_Normal">Operand encoding schemes</p>
<p class="p_Normal">Addressing modes</p>
<p class="p_Normal">Exception handling details</p>
<p class="p_Normal">Alternative: Parameterized Instruction Engine</p>
<p class="p_Normal">Instead of plugins, consider a template-based instruction grain approach:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Single VS Project Structure:</p>
<p class="p_Normal">EmulatorCore/</p>
<p class="p_Normal">├── Instructions/</p>
<p class="p_Normal">│ &nbsp; ├── ArithmeticInstructions.cpp &nbsp; &nbsp;// ADD, SUB, MUL, DIV templates</p>
<p class="p_Normal">│ &nbsp; ├── LogicalInstructions.cpp &nbsp; &nbsp; &nbsp; // AND, OR, XOR templates</p>
<p class="p_Normal">│ &nbsp; ├── MemoryInstructions.cpp &nbsp; &nbsp; &nbsp; &nbsp;// MOV, LOAD, STORE templates</p>
<p class="p_Normal">│ &nbsp; └── ControlInstructions.cpp &nbsp; &nbsp; &nbsp; // BRANCH, CALL, RET templates</p>
<p class="p_Normal">├── Architecture/</p>
<p class="p_Normal">│ &nbsp; ├── VAXContext.h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 32-bit specializations</p>
<p class="p_Normal">│ &nbsp; ├── AlphaContext.h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 64-bit specializations</p>
<p class="p_Normal">│ &nbsp; └── ArchitectureTraits.h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Common interface</p>
<p class="p_Normal">└── Core/</p>
<p class="p_Normal"> &nbsp; &nbsp;├── InstructionDecoder.cpp &nbsp; &nbsp; &nbsp; &nbsp;// Architecture-aware decoder</p>
<p class="p_Normal"> &nbsp; &nbsp;└── ExecutionEngine.cpp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Unified execution core</p>
<p class="p_Normal">Instruction Grain Implementation:</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">template&lt;typename ArchTraits&gt;</p>
<p class="p_Normal">class ADD_Instruction {</p>
<p class="p_Normal"> &nbsp; &nbsp;using WordType = typename ArchTraits::WordType; &nbsp;// uint32_t or uint64_t</p>
<p class="p_Normal"> &nbsp; &nbsp;using RegisterFile = typename ArchTraits::RegisterFile;</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal">public:</p>
<p class="p_Normal"> &nbsp; &nbsp;void execute(RegisterFile&amp; regs, const DecodedInstruction&amp; instr) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;WordType src1 = regs.read(instr.src1_reg);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;WordType src2 = get_operand&lt;ArchTraits&gt;(regs, instr.src2);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;WordType result = src1 + src2;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Architecture-specific flag handling</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;ArchTraits::set_condition_codes(regs, result, src1, src2);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;regs.write(instr.dest_reg, result);</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">};</p>
<p class="p_Normal">Architecture Traits Specialization:</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">struct VAXTraits {</p>
<p class="p_Normal"> &nbsp; &nbsp;using WordType = uint32_t;</p>
<p class="p_Normal"> &nbsp; &nbsp;using RegisterFile = VAXRegisterFile;</p>
<p class="p_Normal"> &nbsp; &nbsp;static constexpr int WORD_SIZE = 32;</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;static void set_condition_codes(RegisterFile&amp; regs, uint32_t result, </p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t op1, uint32_t op2) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX-specific PSW flag setting</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">};</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">struct AlphaTraits {</p>
<p class="p_Normal"> &nbsp; &nbsp;using WordType = uint64_t;</p>
<p class="p_Normal"> &nbsp; &nbsp;using RegisterFile = AlphaRegisterFile;</p>
<p class="p_Normal"> &nbsp; &nbsp;static constexpr int WORD_SIZE = 64;</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;static void set_condition_codes(RegisterFile&amp; regs, uint64_t result, </p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64_t op1, uint64_t op2) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Alpha-specific condition handling</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">};</p>
<p class="p_Normal">Addressing Your FCPR Example:</p>
<p class="p_Normal">For your floating-point control register example:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">template&lt;typename ArchTraits&gt;</p>
<p class="p_Normal">class FloatingPointUnit {</p>
<p class="p_Normal"> &nbsp; &nbsp;typename ArchTraits::FPControlReg fcpr;</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal">public:</p>
<p class="p_Normal"> &nbsp; &nbsp;void set_rounding_mode(int mode) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;ArchTraits::set_fp_rounding(fcpr, mode);</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">};</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">// VAX: 32-bit FCPR with VAX-specific bit layout</p>
<p class="p_Normal">struct VAXTraits {</p>
<p class="p_Normal"> &nbsp; &nbsp;using FPControlReg = uint32_t;</p>
<p class="p_Normal"> &nbsp; &nbsp;static void set_fp_rounding(uint32_t&amp; fcpr, int mode) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX-specific bit manipulation</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">};</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">// Alpha: 64-bit FPCR with IEEE 754 layout &nbsp;</p>
<p class="p_Normal">struct AlphaTraits {</p>
<p class="p_Normal"> &nbsp; &nbsp;using FPControlReg = uint64_t;</p>
<p class="p_Normal"> &nbsp; &nbsp;static void set_fp_rounding(uint64_t&amp; fcpr, int mode) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Alpha-specific bit manipulation</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">};</p>
<p class="p_Normal">Single Project Benefits:</p>
<p class="p_Normal">Unified Codebase: One instruction implementation serves both architectures</p>
<p class="p_Normal">Compile-Time Optimization: Templates allow compiler to optimize for specific architecture</p>
<p class="p_Normal">Shared Logic: Common instruction semantics in one place</p>
<p class="p_Normal">Easy Maintenance: Single point of change for instruction behavior</p>
<p class="p_Normal">Boot-Time Architecture Selection:</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">std::unique_ptr&lt;EmulatorCore&gt; create_emulator(ArchitectureType arch) {</p>
<p class="p_Normal"> &nbsp; &nbsp;switch(arch) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;case VAX:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return std::make_unique&lt;EmulatorCore&lt;VAXTraits&gt;&gt;();</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;case ALPHA:</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return std::make_unique&lt;EmulatorCore&lt;AlphaTraits&gt;&gt;();</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">}</p>
<p class="p_Normal">This approach gives you the architectural flexibility you need while keeping the instruction implementations unified, just as Sites and Witek suggest - the instructions are conceptually the same, just with different operational parameters.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Would this template-based approach better match what you're envisioning? It keeps everything in one VS project while still providing the architectural switching capability you need.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">ADDG_InstructionGrain.h</p>
<p class="p_Normal">83 lines</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">txt</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">ADDL_InstructionGrain.h</p>
<p class="p_Normal">88 lines</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">txt</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">ADDT_C_InstructionGrain.h</p>
<p class="p_Normal">70 lines</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">txt</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">GrainResolver.h</p>
<p class="p_Normal">725 lines</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">txt</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">GrainResolver.cpp</p>
<p class="p_Normal">513 lines</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">txt</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">No - that won't work. &nbsp;It needs to be more granular. &nbsp;I am loading a grain resolver and from within my instruction loop am dispatching to the grain as a high-performant lookup. &nbsp;A follow-up to this will decode once and execute many for additional performance. &nbsp;This will likely occur after invoking the register for the first time. &nbsp;From a grain standpoint, this seems to conform to a standard implementation.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">You're absolutely right - looking at your existing GrainResolver implementation, I can see this is already a well-architected solution for high-performance instruction dispatch. The grain-per-instruction approach with platform-aware resolution is exactly what you need for multi-architecture support.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Your current design is actually optimal for what you're trying to achieve:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Current Architecture Strengths</p>
<p class="p_Normal">High-Performance Dispatch: The makeKey(opcode, func) creates a direct hash lookup - O(1) instruction resolution, which is critical for emulation performance.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Platform-Aware Resolution: Your resolver already handles the architecture switching you need:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">// Platform precedence logic in resolve()</p>
<p class="p_Normal">1. Exact platform match (Alpha/VAX/Tru64/Unix) &nbsp;</p>
<p class="p_Normal">2. Fallback to related platforms</p>
<p class="p_Normal">3. Default to Alpha</p>
<p class="p_Normal">Granular Instruction Grains: Each instruction variant gets its own grain class (ADDG, ADDL, ADDT_C, etc.) which is perfect for handling the architectural differences you mentioned.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">For VAX Integration</p>
<p class="p_Normal">Rather than changing your fundamental architecture, you'd extend it by:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">1. Add VAX-Specific Grains</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">// VAX versions alongside your existing Alpha grains</p>
<p class="p_Normal">registerGrain(new ADDL_VAX_InstructionGrain()); &nbsp;// 32-bit VAX ADDL</p>
<p class="p_Normal">registerGrain(new ADDL_InstructionGrain()); &nbsp; &nbsp; &nbsp;// 64-bit Alpha ADDL</p>
<p class="p_Normal">2. Extend ProcessorArchMode Enum</p>
<p class="p_Normal">Your ProcessorArchModes already supports this - just ensure VAX is included:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">enum ProcessorArchMode {</p>
<p class="p_Normal"> &nbsp; &nbsp;VAX, &nbsp; &nbsp; // 32-bit CISC</p>
<p class="p_Normal"> &nbsp; &nbsp;Alpha, &nbsp; // 64-bit RISC &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;Tru64,</p>
<p class="p_Normal"> &nbsp; &nbsp;Unix</p>
<p class="p_Normal">};</p>
<p class="p_Normal">3. Boot-Time Architecture Selection</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">// At emulator startup</p>
<p class="p_Normal">GrainResolver::instance().setPlatform(ProcessorArchMode::VAX, true);</p>
<p class="p_Normal">// or</p>
<p class="p_Normal">GrainResolver::instance().setPlatform(ProcessorArchMode::Alpha, true);</p>
<p class="p_Normal">Your FCPR Example Handled Perfectly</p>
<p class="p_Normal">This design naturally handles your floating-point control register differences:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">class ADDG_VAX_InstructionGrain : public VAXInstructionGrain {</p>
<p class="p_Normal"> &nbsp; &nbsp;void execute(...) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// 32-bit VAX FCPR handling</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;uint32_t fcpr = context-&gt;getVAXFCPR();</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX-specific floating-point logic</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">};</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">class ADDG_InstructionGrain : public AlphaInstructionGrain {</p>
<p class="p_Normal"> &nbsp; &nbsp;void execute(...) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// 64-bit Alpha FPCR handling &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;uint64_t fpcr = context-&gt;getAlphaFPCR();</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Alpha-specific IEEE 754 logic</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">};</p>
<p class="p_Normal">Performance Benefits You've Already Achieved</p>
<p class="p_Normal">Single decode, multiple executions: Your grain caching approach supports this</p>
<p class="p_Normal">Minimal runtime overhead: Platform resolution happens once during grain lookup</p>
<p class="p_Normal">Scalable: Easy to add new architectures without touching existing code</p>
<p class="p_Normal">Your existing design is sophisticated and production-ready. The question isn't whether to change the architecture - it's simply about implementing VAX-specific instruction grains alongside your existing Alpha ones. The GrainResolver's platform-aware dispatch will handle the runtime switching automatically.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Have you started implementing any VAX instruction grains yet, or are you still in the architectural planning phase?</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Ah. &nbsp;So it really doesn't make sense to encode a flag on the grain to the type (we are doing that already). &nbsp;It seems to me that if the flag is set to VAX, we would perform a bitwise function change in the decode function. &nbsp;I ask as we have ~ 700 grains already. &nbsp;Many are coded for 32 bit already.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">You're absolutely right - with 700 grains already implemented, creating duplicate VAX versions would be inefficient and unmaintainable. Your instinct about modifying the decode function based on architecture flags is much more practical.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Looking at your existing grain structure, you already have the platform flags in place. The key insight is that many instructions are conceptually identical between VAX and Alpha - they just need different bit manipulation during decode and different data width handling during execution.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Architecture-Aware Decode Function</p>
<p class="p_Normal">Instead of separate VAX grains, modify your existing decode functions:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">void decode(quint64 rawInstr, AlphaCPU* argCpu) override final {</p>
<p class="p_Normal"> &nbsp; &nbsp;if (GrainResolver::instance().isVaxMode()) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX-specific bit field extraction (32-bit focused)</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_opcode = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 24) &amp; 0xFF); &nbsp;// Different bit positions</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_ra = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 18) &amp; 0x1F); &nbsp; &nbsp; &nbsp;// VAX register encoding</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX immediate handling, operand modes, etc.</p>
<p class="p_Normal"> &nbsp; &nbsp;} else {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Alpha decode (your existing code)</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_opcode = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 26) &amp; 0x3F);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_ra = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 21) &amp; 0x1F);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_rb = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 16) &amp; 0x1F);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_rc = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 11) &amp; 0x1F);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_function = static_cast&lt;quint16&gt;(rawInstr &amp; 0x7FF);</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">}</p>
<p class="p_Normal">Architecture-Aware Execution</p>
<p class="p_Normal">Similarly, your execute functions can branch based on architecture:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">void execute(AlphaCPU* argCpu, AlphaProcessorContext* context, quint64 rawInstr) const override final {</p>
<p class="p_Normal"> &nbsp; &nbsp;if (GrainResolver::instance().isVaxMode()) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// 32-bit VAX arithmetic</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;uint32_t src1 = context-&gt;readVAXRegister32(m_ra);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;uint32_t src2 = context-&gt;readVAXRegister32(m_rb);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;uint32_t result = src1 + src2;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX-specific condition code handling</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;context-&gt;setVAXConditionCodes(result, src1, src2);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;context-&gt;writeVAXRegister32(m_rc, result);</p>
<p class="p_Normal"> &nbsp; &nbsp;} else {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Your existing Alpha 64-bit logic</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;quint64 src1 = context-&gt;readAlphaRegister(m_ra);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;quint64 src2 = context-&gt;readAlphaRegister(m_rb);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;quint64 result = src1 + src2;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;context-&gt;writeAlphaRegister(m_rc, result);</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">}</p>
<p class="p_Normal">Your FCPR Example Handled</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">void handleFloatingPoint() {</p>
<p class="p_Normal"> &nbsp; &nbsp;if (GrainResolver::instance().isVaxMode()) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;uint32_t fcpr = context-&gt;getVAXFCPR(); &nbsp;// 32-bit VAX format</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX floating-point exception handling</p>
<p class="p_Normal"> &nbsp; &nbsp;} else {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;uint64_t fpcr = context-&gt;getAlphaFPCR(); // 64-bit Alpha format</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// IEEE 754 exception handling</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">}</p>
<p class="p_Normal">Benefits of This Approach</p>
<p class="p_Normal">Reuse Existing Code: Your 700 grains become dual-architecture with minimal changes</p>
<p class="p_Normal">Single Maintenance Point: One grain handles both architectures</p>
<p class="p_Normal">Runtime Switching: Architecture determined at boot, consistent throughout execution</p>
<p class="p_Normal">Gradual Migration: You can convert grains one-by-one as needed</p>
<p class="p_Normal">Considerations</p>
<p class="p_Normal">Performance: The architecture check adds one branch per instruction, but modern branch prediction makes this negligible</p>
<p class="p_Normal">Code Clarity: Keep VAX and Alpha logic clearly separated within each function</p>
<p class="p_Normal">Testing: You'll need test coverage for both architecture paths in each grain</p>
<p class="p_Normal">This approach leverages your existing investment while adding VAX support efficiently. The architecture flag check becomes your switching mechanism, exactly as you suggested.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">AlphaMemorySystem_refactored.cpp</p>
<p class="p_Normal">3,914 lines</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">txt</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">SafeMemory_refactored.cpp</p>
<p class="p_Normal">1,103 lines</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">txt</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">How would this be implemented in SafeMemory and AlphaMemorySystem?</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Based on your existing architecture, the VAX/Alpha architecture switching can be implemented efficiently by modifying the decode and execute phases in your existing grains and memory systems. Here's how to implement this:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">1. Architecture Context Detection</p>
<p class="p_Normal">First, add architecture detection to your existing systems:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">In GrainResolver:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">// Add to GrainResolver.h</p>
<p class="p_Normal">enum class ArchitectureMode {</p>
<p class="p_Normal"> &nbsp; &nbsp;VAX_32BIT,</p>
<p class="p_Normal"> &nbsp; &nbsp;ALPHA_64BIT</p>
<p class="p_Normal">};</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">class GrainResolver {</p>
<p class="p_Normal">private:</p>
<p class="p_Normal"> &nbsp; &nbsp;ArchitectureMode m_currentArchitecture = ArchitectureMode::ALPHA_64BIT;</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal">public:</p>
<p class="p_Normal"> &nbsp; &nbsp;void setArchitecture(ArchitectureMode arch) { m_currentArchitecture = arch; }</p>
<p class="p_Normal"> &nbsp; &nbsp;bool isVaxMode() const { return m_currentArchitecture == ArchitectureMode::VAX_32BIT; }</p>
<p class="p_Normal"> &nbsp; &nbsp;bool isAlphaMode() const { return m_currentArchitecture == ArchitectureMode::ALPHA_64BIT; }</p>
<p class="p_Normal">};</p>
<p class="p_Normal">2. Modify Existing Grain Decode Functions</p>
<p class="p_Normal">Update your existing grains to handle both architectures:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">Example for ADDL_InstructionGrain.h:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">void decode(quint64 rawInstr, AlphaCPU* argCpu) override final {</p>
<p class="p_Normal"> &nbsp; &nbsp;Q_UNUSED(argCpu)</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;if (GrainResolver::instance().isVaxMode()) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX 32-bit instruction format</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_opcode = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 24) &amp; 0xFF); &nbsp;// VAX opcode position</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_ra = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 19) &amp; 0x1F); &nbsp; &nbsp; // VAX register encoding</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_rb = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 14) &amp; 0x1F);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_rc = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 9) &amp; 0x1F);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX doesn't use function codes the same way</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_function = 0;</p>
<p class="p_Normal"> &nbsp; &nbsp;} else {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Your existing Alpha decode</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_opcode = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 26) &amp; 0x3F);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_ra = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 21) &amp; 0x1F);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_rb = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 16) &amp; 0x1F);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_rc = static_cast&lt;quint8&gt;((rawInstr &gt;&gt; 11) &amp; 0x1F);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_function = static_cast&lt;quint16&gt;(rawInstr &amp; 0x7FF);</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">}</p>
<p class="p_Normal">3. Modify Execute Functions for Dual Architecture</p>
<p class="p_Normal">Example for ADDL_InstructionGrain execute:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">void ADDL_InstructionGrain::execute(AlphaCPU* argCpu, AlphaProcessorContext* context, quint64 rawInstr) const {</p>
<p class="p_Normal"> &nbsp; &nbsp;if (GrainResolver::instance().isVaxMode()) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX 32-bit arithmetic</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;quint32 src1 = static_cast&lt;quint32&gt;(context-&gt;readRegister(m_ra));</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;quint32 src2 = static_cast&lt;quint32&gt;(context-&gt;readRegister(m_rb));</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;quint32 result = src1 + src2;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX condition code handling (different from Alpha)</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;context-&gt;setVAXConditionCodes(result, src1, src2);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Sign-extend to 64-bit for storage in register</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;context-&gt;writeRegister(m_rc, static_cast&lt;quint64&gt;(static_cast&lt;qint32&gt;(result)));</p>
<p class="p_Normal"> &nbsp; &nbsp;} else {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Your existing Alpha 64-bit logic</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;quint64 src1 = context-&gt;readRegister(m_ra);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;quint64 src2 = context-&gt;readRegister(m_rb);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Alpha: 32-bit operation on low bits, sign-extend result</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;qint32 result32 = static_cast&lt;qint32&gt;(src1) + static_cast&lt;qint32&gt;(src2);</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;context-&gt;writeRegister(m_rc, static_cast&lt;quint64&gt;(result32));</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">}</p>
<p class="p_Normal">4. AlphaMemorySystem Architecture-Aware Methods</p>
<p class="p_Normal">Add architecture detection in AlphaMemorySystem:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">// Add to AlphaMemorySystem.h</p>
<p class="p_Normal">private:</p>
<p class="p_Normal"> &nbsp; &nbsp;ArchitectureMode m_currentArchitecture = ArchitectureMode::ALPHA_64BIT;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">public:</p>
<p class="p_Normal"> &nbsp; &nbsp;void setArchitecture(ArchitectureMode arch) { </p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;m_currentArchitecture = arch; </p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Sync with GrainResolver</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;GrainResolver::instance().setArchitecture(arch);</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;bool isVaxMode() const { return m_currentArchitecture == ArchitectureMode::VAX_32BIT; }</p>
<p class="p_Normal">Modify memory operations to handle different word sizes:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">bool AlphaMemorySystem::readVirtualMemory(quint16 cpuId, quint64 virtualAddr, quint64 &amp;value, int size) {</p>
<p class="p_Normal"> &nbsp; &nbsp;// ... existing translation logic ...</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;if (isVaxMode()) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX uses different page sizes and address translation</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;return readVirtualMemoryVAX(cpuId, virtualAddr, value, size);</p>
<p class="p_Normal"> &nbsp; &nbsp;} else {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Your existing Alpha logic</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;return readVirtualMemoryAlpha(cpuId, virtualAddr, value, size);</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">}</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">private:</p>
<p class="p_Normal">bool AlphaMemorySystem::readVirtualMemoryVAX(quint16 cpuId, quint64 virtualAddr, quint64 &amp;value, int size) {</p>
<p class="p_Normal"> &nbsp; &nbsp;// VAX-specific translation (512-byte pages, different TLB format)</p>
<p class="p_Normal"> &nbsp; &nbsp;TranslationResult result = translateVAX(cpuId, virtualAddr, false);</p>
<p class="p_Normal"> &nbsp; &nbsp;if (!result.isValid()) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;return false;</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;return accessPhysicalMemory(result.getPhysicalAddress(), value, size, false, 0, cpuId);</p>
<p class="p_Normal">}</p>
<p class="p_Normal">5. SafeMemory Architecture Support</p>
<p class="p_Normal">Add VAX-specific data handling in SafeMemory:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">// Add to SafeMemory.cpp</p>
<p class="p_Normal">quint32 SafeMemory::readVAXLongword(quint64 address, quint64 pc, quint16 cpuId) {</p>
<p class="p_Normal"> &nbsp; &nbsp;if (address &amp; 3) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;throw MemoryAccessException(MemoryFaultType::ALIGNMENT_FAULT, address, 4, false, pc);</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;QReadLocker locker(&amp;m_memoryLock);</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;if (!isValidAddress(address, 4)) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;throw MemoryAccessException(MemoryFaultType::INVALID_ADDRESS, address, 4, false, pc);</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;// VAX uses little-endian like Alpha, so same byte order</p>
<p class="p_Normal"> &nbsp; &nbsp;quint32 value = qFromLittleEndian&lt;quint32&gt;(&amp;m_ram[static_cast&lt;int&gt;(address)]);</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;updateCPUAccessTracking(cpuId, address, false);</p>
<p class="p_Normal"> &nbsp; &nbsp;emit sigMemoryRead(address, value, 4);</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;return value;</p>
<p class="p_Normal">}</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">void SafeMemory::writeVAXLongword(quint64 address, quint32 value, quint64 pc, quint16 cpuId) {</p>
<p class="p_Normal"> &nbsp; &nbsp;if (address &amp; 3) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;throw MemoryAccessException(MemoryFaultType::ALIGNMENT_FAULT, address, 4, true, pc);</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;QWriteLocker locker(&amp;m_memoryLock);</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;if (!isValidAddress(address, 4)) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;return;</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;qToLittleEndian(value, &amp;m_ram[static_cast&lt;int&gt;(address)]);</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;clearOverlappingReservations(address, 4, cpuId);</p>
<p class="p_Normal"> &nbsp; &nbsp;updateCPUAccessTracking(cpuId, address, true);</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;emit sigMemoryWritten(address, value, 4);</p>
<p class="p_Normal">}</p>
<p class="p_Normal">6. Boot-Time Architecture Selection</p>
<p class="p_Normal">Add to your main emulator initialization:</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">void EmulatorCore::setTargetArchitecture(const QString&amp; arch) {</p>
<p class="p_Normal"> &nbsp; &nbsp;ArchitectureMode mode;</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;if (arch.toUpper() == &quot;VAX&quot;) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;mode = ArchitectureMode::VAX_32BIT;</p>
<p class="p_Normal"> &nbsp; &nbsp;} else if (arch.toUpper() == &quot;ALPHA&quot;) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;mode = ArchitectureMode::ALPHA_64BIT;</p>
<p class="p_Normal"> &nbsp; &nbsp;} else {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;throw std::invalid_argument(&quot;Unknown architecture: &quot; + arch.toStdString());</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;// Set architecture across all systems</p>
<p class="p_Normal"> &nbsp; &nbsp;m_memorySystem-&gt;setArchitecture(mode);</p>
<p class="p_Normal"> &nbsp; &nbsp;GrainResolver::instance().setArchitecture(mode);</p>
<p class="p_Normal"> &nbsp; &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp;DEBUG_LOG(QString(&quot;Emulator configured for %1 architecture&quot;).arg(arch));</p>
<p class="p_Normal">}</p>
<p class="p_Normal">Key Benefits of This Approach:</p>
<p class="p_Normal">Reuses Existing Code: Your 700 grains just need decode/execute modifications</p>
<p class="p_Normal">Single Binary: One executable supports both architectures</p>
<p class="p_Normal">Runtime Switching: Architecture determined at boot time</p>
<p class="p_Normal">Minimal Performance Impact: Single branch per instruction</p>
<p class="p_Normal">Maintains Compatibility: Existing Alpha code continues to work</p>
<p class="p_Normal">Your FCPR Example Implementation:</p>
<p class="p_Normal">cpp</p>
<p class="p_Normal">void handleFloatingPointControl() {</p>
<p class="p_Normal"> &nbsp; &nbsp;if (GrainResolver::instance().isVaxMode()) {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;quint32 fcpr = context-&gt;getVAXFCPR(); &nbsp;// 32-bit VAX format</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// VAX floating-point logic with different bit layout</p>
<p class="p_Normal"> &nbsp; &nbsp;} else {</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;quint64 fpcr = context-&gt;getAlphaFPCR(); // 64-bit Alpha format &nbsp;</p>
<p class="p_Normal"> &nbsp; &nbsp; &nbsp; &nbsp;// Alpha IEEE 754 logic</p>
<p class="p_Normal"> &nbsp; &nbsp;}</p>
<p class="p_Normal">}</p>
<p class="p_Normal">This approach maximizes your existing investment while efficiently adding VAX support. The architecture check becomes your switching mechanism, exactly as you envisioned.</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>
<p class="p_Normal">&nbsp;</p>

<!--ZOOMSTOP-->
</div></div>
<script type="text/javascript">



function normHeaders() {
 var topicHeadHeight =  $("#idheaderbg > table").first().height() + 1,
	 $topicHeaderBox = $("#idheader"),
	 $topicContentBox = $("#idcontent"),
	 $navHeader = $("#navbar", parent.document),			 
	$navBox = $("div#hmnavframe", parent.document),
	 navHeaderHeight = $navHeader.height();
 if (topicHeadHeight != navHeaderHeight) {
	 $navHeader.css("height",topicHeadHeight + "px");
	 $navBox.css("top", topicHeadHeight + "px");
	 $topicHeaderBox.css("height", topicHeadHeight + "px");
		if ($topicHeaderBox.css("position") == "fixed"){
			$topicContentBox.css("margin-top", topicHeadHeight + "px");
			}
		}
    }
			 
  $(document).ready(function(){
    $(window).on('resize', function() {
      var y = $('#idheader').height(); 
      $('#idcontent').css('margin-top', y);
      var par = window.parent;
      if ($( par ).width() <= $( window ).width()+20) {
        $('#idheader').css('position', 'relative');
        $('#idcontent').css('margin-top', 0);
        $('#idbacktotop').css('display', 'block');
        $('.hmanchor').css('margin-top', -20);
	$('.hmanchor').css('padding-top', 20);
      }
      else {
        $('#idheader').css('position', 'fixed');
        $('#idcontent').css('margin-top', $('#idheader').height());
        $('#idbacktotop').css('display', 'none');
        $('.hmanchor').css('margin-top', -y-20);
		$('.hmanchor').css('padding-top', y+20);
		$("div#hmsplitter", parent.document).css('width', '3px');
      }
	normHeaders();
    });
    
	 $(window).resize(); //trigger event for initially small displays
  });
 

if ((!parent.hmNavigationFrame) && (parent.location) && (parent.location.href)) { $('.sync-toc').show();$('p.crumbs').hide();}

</script>
</body>
</html>
